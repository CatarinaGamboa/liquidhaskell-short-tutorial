<h1 id="refined-data-types">Refined Data Types</h1>

<h2 id="refining-data-types-sparse-vectors">Refining Data Types: Sparse Vectors</h2>
<p>While the standard <code>Vector</code> is great for <em>dense</em> arrays, often we have to manipulate <em>sparse</em> vectors where most elements are just <code>0</code>. We might represent such vectors as a list of index-value tuples:</p>
<pre><span class=hs-linenum>31: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spSize</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>32: </span>                   <span class='hs-layout'>,</span> <span class='hs-varid'>spElems</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span> 
</pre>
<p>Implicitly, all indices <em>other</em> than those in the list have the value <code>0</code> (or the equivalent value for the type <code>a</code>).</p>
<p> Unfortunately, Haskell's type system does not make it easy to represent the fact that every <em>legal</em> <code>Sparse</code> vector has indices that are between <code>0</code> and <code>spSize</code>. Fortunately, this is easy to describe as a data type refinement in LiquidHaskell:</p>
<pre><span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spSize</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> 
<span class=hs-linenum>45: </span>                       <span class='hs-layout'>,</span> <span class='hs-varid'>spElems</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Btwn</span> <span class='hs-num'>0</span> <span class='hs-varid'>spSize</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>In the above, we specify that <code>spSize</code> is non-negative, and each index is indeed valid. Consequently LiquidHaskell verifies:</p>
<pre><span class=hs-linenum>52: </span><span class='hs-definition'>okSP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Sparse</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>53: </span><span class='hs-definition'>okSP</span><span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>5</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-str'>"cat"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-str'>"dog"</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
</pre>
<p>but rejects:</p>
<pre><span class=hs-linenum>59: </span><span class='hs-definition'>badSP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Sparse</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>60: </span><span class='hs-definition'>badSP</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>5</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-str'>"cat"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>6</span><span class='hs-layout'>,</span> <span class='hs-str'>"dog"</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
</pre>
<p> It is convenient to write an alias for sparse vectors of a given size <code>N</code>; note that the field name <code>spSize</code> are <em>measures</em>, like <code>vlen</code>, and can be used inside refinements:</p>
<pre><span class=hs-linenum>69: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>SparseN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>spSize</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-conid'>N</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span> 
</pre>
<p>The alias <code>SparseN</code> is just a shorthand for the (longer) type on the right, it does not <em>define</em> a new type. If you are familiar with the <em>index-style</em> length encoding e.g. as found in <a href="http://www.cs.bu.edu/~hwxi/DML/DML.html">DML</a> or <a href="http://code.haskell.org/Agda/examples/Vec.agda">Agda</a>, then note that despite appearances, our <code>Sparse</code> definition is <em>not</em> indexed.</p>
<p> Lets write a function to compute a sparse product</p>
<pre><span class=hs-linenum>83: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>sparseProduct</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Vector</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>vlen</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>84: </span><span class='hs-definition'>sparseProduct</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>SP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>85: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>86: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>y'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>!</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>y'</span> 
<span class=hs-linenum>87: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>sum</span> <span class='hs-conid'>[]</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span>
</pre>
<p>LiquidHaskell verifies the above by using the specification to conclude that for each tuple <code>(i, v)</code> in the list <code>y</code>, the value of <code>i</code> is within the bounds of the vector <code>x</code>, thereby proving <code>x ! i</code> safe.</p>
<h2 id="refinements-and-polymorphism">Refinements and Polymorphism</h2>
<p>The sharp reader will have undoubtedly noticed that the sparse product can be more cleanly expressed as a <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html">fold</a>:</p>
<pre><span class=hs-linenum>102: </span><span class='hs-definition'>foldl'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
</pre>
<p>We can simply fold over the sparse vector, accumulating the <code>sum</code> as we go along</p>
<pre><span class=hs-linenum>109: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>sparseProduct'</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Vector</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>vlen</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>110: </span><span class='hs-definition'>sparseProduct'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>SP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>body</span> <span class='hs-num'>0</span> <span class='hs-varid'>y</span>   
<span class=hs-linenum>111: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>112: </span>    <span class='hs-varid'>body</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>!</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>  <span class='hs-varop'>*</span> <span class='hs-varid'>v</span>
</pre>
<p>LiquidHaskell digests this too, without much difficulty. The main trick is in how the polymorphism of <code>foldl'</code> is instantiated.</p>
<ol style="list-style-type: decimal">
<li><p>The GHC type inference engine deduces that at this site, the type variable <code>b</code> from the signature of <code>foldl'</code> is instantiated to the Haskell type <code>(Int, a)</code>.</p></li>
<li><p>Correspondingly, LiquidHaskell infers that in fact <code>b</code> can be instantiated to the <em>refined</em> <code>(Btwn 0 v (vlen x), a)</code>.</p></li>
</ol>
<p>Thus, the inference mechanism saves us a fair bit of typing and allows us to reuse existing polymorphic functions over containers and such without ceremony.</p>
<p> for now! Hopefully the above gives you a reasonable idea of how one can use refinements to verify size related properties, and more generally, to specify and verify properties of recursive, and polymorphic functions operating over datatypes. Read on to learn how we can teach LiquidHaskell to reason about <em>structural</em> properties of data types.</p>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

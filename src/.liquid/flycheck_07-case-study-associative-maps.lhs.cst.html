<h1 id="case-study-associative-maps">Case Study: Associative Maps</h1>
<p>\begin{comment}</p>
<pre><span class=hs-linenum> 7: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 8: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--diff"</span>           <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 9: </span>
<span class=hs-linenum>10: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>AssocativeMap</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>11: </span>
<span class=hs-linenum>12: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span><span class='hs-layout'>)</span>
<span class=hs-linenum>13: </span><span class='hs-comment'>-- | Boilerplate </span>
<span class=hs-linenum>14: </span>
<span class=hs-linenum>15: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>die</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| false}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>16: </span><a class=annot href="#"><span class=annottext>forall t. lq_tmp_x1181:{v : [GHC.Types.Char] | false} -&gt; t</span><span class='hs-definition'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false}</span><span class='hs-varid'>x</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1188:[GHC.Types.Char^"lq_tmp_x1"]&lt;\lq_tmp_x1184 VV -&gt; True&gt;^"lq_tmp_x3"
-&gt; {VV#1189 : t^"lq_tmp_x1191" "lq_tmp_x4" | k_1190}</span><span class='hs-varid'>error</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1195 : [GHC.Types.Char] | false &amp;&amp; len lq_tmp_x1195 &gt;= 0 &amp;&amp; lq_tmp_x1195 == x#a1ly}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>17: </span>
<span class=hs-linenum>18: </span><span class='hs-comment'>-- | Haskell Definitions</span>
<span class=hs-linenum>19: </span>
<span class=hs-linenum>20: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x2756:(AssocativeMap.Map k^"lq_tmp_x191" v^"lq_tmp_x192")^"lq_tmp_x193"
-&gt; k^"lq_tmp_x194"</span><span class='hs-varid'>key</span></a>   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>21: </span>                    <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x2709:(AssocativeMap.Map k^"lq_tmp_x186" v^"lq_tmp_x187")^"lq_tmp_x188"
-&gt; v^"lq_tmp_x189"</span><span class='hs-varid'>value</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>22: </span>                    <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x2654:(AssocativeMap.Map k^"lq_tmp_x179" v^"lq_tmp_x180")^"lq_tmp_x181"
-&gt; (AssocativeMap.Map k^"lq_tmp_x182" v^"lq_tmp_x183")^"lq_tmp_x184"</span><span class='hs-varid'>left</span></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>23: </span>                    <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x2599:(AssocativeMap.Map k^"lq_tmp_x172" v^"lq_tmp_x173")^"lq_tmp_x174"
-&gt; (AssocativeMap.Map k^"lq_tmp_x175" v^"lq_tmp_x176")^"lq_tmp_x177"</span><span class='hs-varid'>right</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>24: </span>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Tip</span> 
<span class=hs-linenum>25: </span>
<span class=hs-linenum>26: </span><span class='hs-definition'>lemma_notMem</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> 
<span class=hs-linenum>27: </span><span class='hs-definition'>set</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>28: </span><span class='hs-definition'>get</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> 
<span class=hs-linenum>29: </span><span class='hs-definition'>get'</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> 
<span class=hs-linenum>30: </span><span class='hs-definition'>mem</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>31: </span><span class='hs-definition'>emp</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>32: </span><span class='hs-definition'>elems</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>33: </span><span class='hs-definition'>fresh</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>34: </span><span class='hs-comment'>-- | Predicate Aliases</span>
<span class=hs-linenum>35: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>NoKey</span> <span class='hs-conid'>M</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>                        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>36: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>HasKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_mem</span> <span class='hs-conid'>K</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>                    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>37: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>PlusKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keys</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_sng</span> <span class='hs-conid'>K</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Subset</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_sub</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span>                           <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Empty</span>  <span class='hs-conid'>X</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_emp</span> <span class='hs-conid'>X</span>                             <span class='hs-keyword'>@-}</span>
</pre>
<p>\end{comment}</p>

<p>Recall the following from the <a href="#intro">introduction</a>.</p>

<p>The problem illustrated above is quite a pervasive one; associative maps pop up everywhere. Failed lookups are the equivalent of <code>NullPointerDereference</code> exceptions in languages like Haskell. It is rather difficult to use Haskell's type system to precisely characterize the behavior of associative map APIs as ultimately, this requires tracking the <em>dynamic set of keys</em> in the map.</p>
<p>In this case study, we'll see how to combine two techniques -- <a href="#setmeasure">measures</a> for reasoning about the <em>sets</em> of elements in structures, and <a href="#refineddatatypes">refined data types</a> for reasoning about order invariants -- can be applied to programs that use associative maps (e.g. <code>Data.Map</code> or <code>Data.HashMap</code>).</p>
<h2 id="mapapi">Specifying Maps</h2>
<p>Lets start by defining a <em>refined API</em> for Associative Maps that tracks the set of keys stored in the map, in order to statically ensure the safety of lookups.</p>
<p> First, we need an (currently abstract) type for <code>Map</code>s. As usual, lets parameterize the type with <code>k</code> for the type of keys and <code>v</code> for the type of values.</p>
<pre><span class=hs-linenum>91: </span><span class='hs-comment'>-- | Data Type</span>
<span class=hs-linenum>92: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span>
</pre>
<p> To talk about the set of keys in a map, we will use a <em>measure</em></p>
<pre><span class=hs-linenum>99: </span><span class='hs-definition'>measure</span> <span class='hs-varid'>keys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>k</span>
</pre>
<p>that associates each <code>Map</code> to the <code>Set</code> of its defined keys. Next, we use the above measure, and the usual <code>Set</code> operators to refine the types of the functions that <em>create</em>, <em>add</em> and <em>lookup</em> key-value bindings, in order to precisely track, within the type system, the <code>keys</code> that are dynamically defined within each <code>Map</code>.</p>
<p> <code>Map</code>s have no keys in them. Hence, we defined a predicate alias, <code>NoKey</code> and use it to type <code>emp</code> which is used to denote the empty <code>Map</code>:</p>
<pre><span class=hs-linenum>114: </span><span class='hs-definition'>emp</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NoKey</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>NoKey</span> <span class='hs-conid'>M</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keys</span> <span class='hs-conid'>M</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_empty</span> <span class='hs-num'>0</span>
</pre>
<p> The function <code>set</code> takes a key <span class="math"><em>k</em></span> a value <span class="math"><em>v</em></span> and a map <code>m</code> and returns the new map obtained by extending <code>m</code> with the binding <span class="math"><em>k</em> ↦ <em>v</em></span>. Thus, the set of <code>keys</code> of the output <code>Map</code> includes those of the input plus the singleton <span class="math"><em>k</em></span>, that is:</p>
<pre><span class=hs-linenum>126: </span><span class='hs-definition'>set</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>n</span><span class='hs-conop'>:</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlusKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span><span class='hs-layout'>}</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>PlusKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keys</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_sng</span> <span class='hs-conid'>K</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>
</pre>
<p> Finally, queries will only succeed for keys that are defined a given <code>Map</code>. Thus, we define an alias:</p>
<pre><span class=hs-linenum>135: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>HasKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_mem</span> <span class='hs-conid'>K</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>
</pre>
<p>and use it to type <code>mem</code> which <em>checks</em> if a key is defined in the <code>Map</code> and <code>get</code> which actually returns the value associated with a given key.</p>
<pre><span class=hs-linenum>143: </span><span class='hs-comment'>-- | Check if key is defined </span>
<span class=hs-linenum>144: </span><span class='hs-definition'>mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Prop</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;=&gt;</span> <span class='hs-conid'>HasKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span><span class='hs-comment'>-- | Lookup key's value </span>
<span class=hs-linenum>147: </span><span class='hs-definition'>get</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HasKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span>
</pre>
<h2 id="using-maps-well-scoped-expressions">Using Maps: Well Scoped Expressions</h2>
<p>Rather than jumping into the <em>implementation</em> of the above <code>Map</code> API, lets write a <em>client</em> that uses <code>Map</code>s to implement an interpreter for a tiny language. In particular, we will use maps as an <em>environment</em> containing the values of <em>bound variables</em>, and we will use the refined API to ensure that <em>lookups never fail</em>, and hence, that well-scoped programs always reduce to a value.</p>
<p> Lets work with a simple language with integer constants, variables, binding and arithmetic operators: </p>
<pre><span class=hs-linenum>166: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>String</span> 
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Const</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>169: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Var</span>   <span class='hs-conid'>Var</span>
<span class=hs-linenum>170: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Plus</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
<span class=hs-linenum>171: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Let</span>   <span class='hs-conid'>Var</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
</pre>
<p> We can use refinements to formally describe <em>values</em> as a subset of <code>Expr</code> allowing us to reuse a bunch of code. To this end, we simply define a (<code>measure</code>) predicate characterizing values:</p>
<pre><span class=hs-linenum>180: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>181: </span><span class='hs-definition'>val</span>              <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> 
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>lq_tmp_x1098:AssocativeMap.Expr
-&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; val lq_tmp_x1098}</span><span class='hs-definition'>val</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1113 : GHC.Types.Bool | Prop lq_tmp_x1113 &amp;&amp; lq_tmp_x1113 == GHC.Types.True#6u}</span><span class='hs-conid'>True</span></a> 
<span class=hs-linenum>183: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1131 : GHC.Types.Bool | not (Prop lq_tmp_x1131) &amp;&amp; lq_tmp_x1131 == GHC.Types.False#68}</span><span class='hs-conid'>False</span></a> 
<span class=hs-linenum>184: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1149 : GHC.Types.Bool | not (Prop lq_tmp_x1149) &amp;&amp; lq_tmp_x1149 == GHC.Types.False#68}</span><span class='hs-conid'>False</span></a> 
<span class=hs-linenum>185: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1179 : GHC.Types.Bool | not (Prop lq_tmp_x1179) &amp;&amp; lq_tmp_x1179 == GHC.Types.False#68}</span><span class='hs-conid'>False</span></a> 
</pre>
<p>and then we can use the lifted <code>measure</code> to define an alias for <code>Val</code> denoting values:</p>
<pre><span class=hs-linenum>192: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>val</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>we can use the above to write simple <em>operators</em> on <code>Val</code>, for example:</p>
<pre><span class=hs-linenum>199: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plus</span>                 <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>200: </span><a class=annot href="#"><span class=annottext>lq_tmp_x1197:{v : AssocativeMap.Expr | val v}
-&gt; lq_tmp_x1198:{v : AssocativeMap.Expr | val v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>plus</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1244:GHC.Types.Int
-&gt; {lq_tmp_x1242 : AssocativeMap.Expr | free lq_tmp_x1242 == Set_empty 0 &amp;&amp; val lq_tmp_x1242 &lt;=&gt; true}</span><span class='hs-conid'>Const</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{lq_tmp_x1238 : GHC.Types.Int | lq_tmp_x1238 == i#a1lz}</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x1232:GHC.Types.Int^"lq_tmp_x1234"
-&gt; lq_tmp_x1233:GHC.Types.Int^"lq_tmp_x1234"
-&gt; {lq_tmp_x1235 : GHC.Types.Int^"lq_tmp_x1234" | lq_tmp_x1235 == lq_tmp_x1232 + lq_tmp_x1233}</span><span class='hs-varop'>+</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x1239 : GHC.Types.Int | lq_tmp_x1239 == j#a1lA}</span><span class='hs-varid'>j</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>201: </span><span class='hs-definition'>plus</span> <span class='hs-keyword'>_</span>         <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1501:{lq_tmp_x1499 : [GHC.Types.Char] | false}
-&gt; {lq_tmp_x1505 : AssocativeMap.Expr^"lq_tmp_x1504" | k_1503[VV#1502:=lq_tmp_x1505]}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1509 : [GHC.Types.Char^"lq_tmp_x10"]&lt;\lq_tmp_x1507 VV -&gt; True&gt;^"lq_tmp_x12" | len lq_tmp_x1509 &gt;= 0 &amp;&amp; lq_tmp_x1509 == lq_anf__d1vj}</span><span class='hs-str'>"Bad call to plus"</span></a>
</pre>
<p> let us save values for the &quot;local&quot; i.e. <em>let-bound</em> variables; when evaluating an expression <code>Var x</code> we simply look up the value of <code>x</code> in the environment. This is why <code>Map</code>s were invented! Lets define our environments as <code>Map</code>s from <code>Var</code>iables to <code>Val</code>ues:</p>
<pre><span class=hs-linenum>211: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Map</span> <span class='hs-conid'>Var</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>The above definition essentially specifies, inside the types, an <em>eager</em> evaluation strategy: LiquidHaskell will prevent us from sticking unevaluated <code>Expr</code>s inside the environments.</p>
<p> proceeds via a straightforward recursion over the structure of the expression. When we hit a <code>Var</code> we simply query its value from the environment. When we hit a <code>Let</code> we compute the bound expression and tuck its value into the environment before proceeding within.</p>
<pre><span class=hs-linenum>225: </span><a class=annot href="#"><span class=annottext>lq_tmp_x1928:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; lq_tmp_x1929:{v : AssocativeMap.Expr | Set_sub free v keys lq_tmp_x1928}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>eval</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV#1982 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=ds_d1uo][lq_tmp_x1988:=ds_d1uo]}</span><span class='hs-varid'>i</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2006 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=ds_d1uo][lq_tmp_x1988:=ds_d1uo][VV#1982:=lq_tmp_x2006][lq_tmp_x1993:=lq_tmp_x2006][lq_tmp_x1995:=lq_tmp_x2006] &amp;&amp; lq_tmp_x2006 == i#a1lB &amp;&amp; lq_tmp_x2006 == AssocativeMap.Const#rqq ds_d1up &amp;&amp; free lq_tmp_x2006 == Set_empty 0 &amp;&amp; val lq_tmp_x2006 &lt;=&gt; true &amp;&amp; lq_tmp_x2006 == lq_anf__d1vR}</span><span class='hs-varid'>i</span></a>
<span class=hs-linenum>226: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1677:k
-&gt; lq_tmp_x1678:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1677 keys m}
-&gt; v</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2058 : [GHC.Types.Char] | len lq_tmp_x2058 &gt;= 0 &amp;&amp; lq_tmp_x2058 == x#a1lD}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2064 : (AssocativeMap.Map {lq_tmp_x2062 : [{lq_tmp_x2059 : GHC.Types.Char^"lq_tmp_x1968" | k_1967[VV#1966:=lq_tmp_x2059][VV#1973:=lq_tmp_x2062][VV#1979:=lq_tmp_x2064]}]&lt;\lq_tmp_x2060 VV -&gt; k_1971[VV#1970:=lq_tmp_x2061][lq_tmp_x1969:=lq_tmp_x2060][VV#1979:=lq_tmp_x2064]&gt;^"lq_tmp_x1975" | k_1974[VV#1973:=lq_tmp_x2062][VV#1979:=lq_tmp_x2064]} {lq_tmp_x2063 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977[VV#1976:=lq_tmp_x2063][VV#1979:=lq_tmp_x2064]})^"lq_tmp_x1981" | k_1980[VV#1979:=lq_tmp_x2064] &amp;&amp; lq_tmp_x2064 == ds_d1uo}</span><span class='hs-varid'>g</span></a> 
<span class=hs-linenum>227: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2127:{lq_tmp_x2122 : AssocativeMap.Expr | val lq_tmp_x2122}
-&gt; lq_tmp_x2128:{lq_tmp_x2123 : AssocativeMap.Expr | val lq_tmp_x2123}
-&gt; {lq_tmp_x2124 : AssocativeMap.Expr | val lq_tmp_x2124}</span><span class='hs-varid'>plus</span></a>  <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1988:{VV#1979 : (AssocativeMap.Map {VV#1973 : [{VV#1966 : GHC.Types.Char^"lq_tmp_x1968" | k_1967}]&lt;\lq_tmp_x1969 VV -&gt; k_1971&gt;^"lq_tmp_x1975" | k_1974} {VV#1976 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977})^"lq_tmp_x1981" | k_1980}
-&gt; lq_tmp_x1989:{VV#1982 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=lq_tmp_x1988]}
-&gt; {VV#1985 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=lq_tmp_x1988][i#a1lB:=lq_tmp_x1989]}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2099 : (AssocativeMap.Map {lq_tmp_x2097 : [{lq_tmp_x2094 : GHC.Types.Char^"lq_tmp_x1968" | k_1967[VV#1966:=lq_tmp_x2094][VV#1973:=lq_tmp_x2097][VV#1979:=lq_tmp_x2099]}]&lt;\lq_tmp_x2095 VV -&gt; k_1971[VV#1970:=lq_tmp_x2096][lq_tmp_x1969:=lq_tmp_x2095][VV#1979:=lq_tmp_x2099]&gt;^"lq_tmp_x1975" | k_1974[VV#1973:=lq_tmp_x2097][VV#1979:=lq_tmp_x2099]} {lq_tmp_x2098 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977[VV#1976:=lq_tmp_x2098][VV#1979:=lq_tmp_x2099]})^"lq_tmp_x1981" | k_1980[VV#1979:=lq_tmp_x2099] &amp;&amp; lq_tmp_x2099 == ds_d1uo}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2100 : AssocativeMap.Expr | lq_tmp_x2100 == e1#a1lF}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1988:{VV#1979 : (AssocativeMap.Map {VV#1973 : [{VV#1966 : GHC.Types.Char^"lq_tmp_x1968" | k_1967}]&lt;\lq_tmp_x1969 VV -&gt; k_1971&gt;^"lq_tmp_x1975" | k_1974} {VV#1976 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977})^"lq_tmp_x1981" | k_1980}
-&gt; lq_tmp_x1989:{VV#1982 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=lq_tmp_x1988]}
-&gt; {VV#1985 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=lq_tmp_x1988][i#a1lB:=lq_tmp_x1989]}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2119 : (AssocativeMap.Map {lq_tmp_x2117 : [{lq_tmp_x2114 : GHC.Types.Char^"lq_tmp_x1968" | k_1967[VV#1966:=lq_tmp_x2114][VV#1973:=lq_tmp_x2117][VV#1979:=lq_tmp_x2119]}]&lt;\lq_tmp_x2115 VV -&gt; k_1971[VV#1970:=lq_tmp_x2116][lq_tmp_x1969:=lq_tmp_x2115][VV#1979:=lq_tmp_x2119]&gt;^"lq_tmp_x1975" | k_1974[VV#1973:=lq_tmp_x2117][VV#1979:=lq_tmp_x2119]} {lq_tmp_x2118 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977[VV#1976:=lq_tmp_x2118][VV#1979:=lq_tmp_x2119]})^"lq_tmp_x1981" | k_1980[VV#1979:=lq_tmp_x2119] &amp;&amp; lq_tmp_x2119 == ds_d1uo}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2120 : AssocativeMap.Expr | lq_tmp_x2120 == e2#a1lG}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span> 
<span class=hs-linenum>228: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1988:{VV#1979 : (AssocativeMap.Map {VV#1973 : [{VV#1966 : GHC.Types.Char^"lq_tmp_x1968" | k_1967}]&lt;\lq_tmp_x1969 VV -&gt; k_1971&gt;^"lq_tmp_x1975" | k_1974} {VV#1976 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977})^"lq_tmp_x1981" | k_1980}
-&gt; lq_tmp_x1989:{VV#1982 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=lq_tmp_x1988]}
-&gt; {VV#1985 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=lq_tmp_x1988][i#a1lB:=lq_tmp_x1989]}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2279 : (AssocativeMap.Map {lq_tmp_x2277 : [{lq_tmp_x2274 : GHC.Types.Char^"lq_tmp_x2229" | k_2228[VV#2227:=lq_tmp_x2274][VV#2234:=lq_tmp_x2277][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo][lq_tmp_x2237:=lq_tmp_x2274][lq_tmp_x2240:=lq_tmp_x2277][lq_tmp_x2218:=lq_tmp_x2279]}]&lt;\lq_tmp_x2275 VV -&gt; k_2232[VV#2231:=lq_tmp_x2276][lq_tmp_x2230:=lq_tmp_x2275][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo][lq_tmp_x2239:=lq_tmp_x2276][lq_tmp_x2238:=lq_tmp_x2275][lq_tmp_x2218:=lq_tmp_x2279]&gt;^"lq_tmp_x2236" | k_2235[VV#2234:=lq_tmp_x2277][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo][lq_tmp_x2240:=lq_tmp_x2277][lq_tmp_x2218:=lq_tmp_x2279]} {lq_tmp_x2278 : AssocativeMap.Expr^"lq_tmp_x2243" | k_2242[VV#2241:=lq_tmp_x2278][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo][lq_tmp_x2244:=lq_tmp_x2278][lq_tmp_x2218:=lq_tmp_x2279]}) | keys lq_tmp_x2279 == Set_cup Set_sng x#a1lI keys ds_d1uo &amp;&amp; lq_tmp_x2279 == g'#a1lL}</span><span class='hs-varid'>g'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2280 : AssocativeMap.Expr | lq_tmp_x2280 == e2#a1lK}</span><span class='hs-varid'>e2</span></a> 
<span class=hs-linenum>229: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>230: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2218 : (AssocativeMap.Map {lq_tmp_x2240 : [{lq_tmp_x2237 : GHC.Types.Char^"lq_tmp_x2229" | k_2228[VV#2227:=lq_tmp_x2237][VV#2234:=lq_tmp_x2240][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo]}]&lt;\lq_tmp_x2238 VV -&gt; k_2232[VV#2231:=lq_tmp_x2239][lq_tmp_x2230:=lq_tmp_x2238][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo]&gt;^"lq_tmp_x2236" | k_2235[VV#2234:=lq_tmp_x2240][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo]} {lq_tmp_x2244 : AssocativeMap.Expr^"lq_tmp_x2243" | k_2242[VV#2241:=lq_tmp_x2244][lq_tmp_x2223:=fix##36#dOrd_a1se][lq_tmp_x2224:=x#a1lI][lq_tmp_x2225:=v1#a1lM][lq_tmp_x2226:=ds_d1uo]}) | keys lq_tmp_x2218 == Set_cup Set_sng x#a1lI keys ds_d1uo}</span><span class='hs-varid'>g'</span></a>               <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x764:k
-&gt; lq_tmp_x765:v
-&gt; lq_tmp_x766:(AssocativeMap.Map k v)
-&gt; {n : (AssocativeMap.Map k v) | keys n == Set_cup Set_sng lq_tmp_x764 keys lq_tmp_x766}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2253 : [GHC.Types.Char] | len lq_tmp_x2253 &gt;= 0 &amp;&amp; lq_tmp_x2253 == x#a1lI}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2254 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=ds_d1uo][i#a1lB:=e1#a1lJ][VV#1985:=lq_tmp_x2254][lq_tmp_x1988:=ds_d1uo][lq_tmp_x1989:=e1#a1lJ][lq_tmp_x2170:=ds_d1uo][lq_tmp_x2171:=e1#a1lJ][lq_tmp_x2167:=lq_tmp_x2254] &amp;&amp; lq_tmp_x2254 == v1#a1lM}</span><span class='hs-varid'>v1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2260 : (AssocativeMap.Map {lq_tmp_x2258 : [{lq_tmp_x2255 : GHC.Types.Char^"lq_tmp_x1968" | k_1967[VV#1966:=lq_tmp_x2255][VV#1973:=lq_tmp_x2258][VV#1979:=lq_tmp_x2260]}]&lt;\lq_tmp_x2256 VV -&gt; k_1971[VV#1970:=lq_tmp_x2257][lq_tmp_x1969:=lq_tmp_x2256][VV#1979:=lq_tmp_x2260]&gt;^"lq_tmp_x1975" | k_1974[VV#1973:=lq_tmp_x2258][VV#1979:=lq_tmp_x2260]} {lq_tmp_x2259 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977[VV#1976:=lq_tmp_x2259][VV#1979:=lq_tmp_x2260]})^"lq_tmp_x1981" | k_1980[VV#1979:=lq_tmp_x2260] &amp;&amp; lq_tmp_x2260 == ds_d1uo}</span><span class='hs-varid'>g</span></a> 
<span class=hs-linenum>231: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2167 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=ds_d1uo][i#a1lB:=e1#a1lJ][VV#1985:=lq_tmp_x2167][lq_tmp_x1988:=ds_d1uo][lq_tmp_x1989:=e1#a1lJ][lq_tmp_x2170:=ds_d1uo][lq_tmp_x2171:=e1#a1lJ]}</span><span class='hs-varid'>v1</span></a>               <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1988:{VV#1979 : (AssocativeMap.Map {VV#1973 : [{VV#1966 : GHC.Types.Char^"lq_tmp_x1968" | k_1967}]&lt;\lq_tmp_x1969 VV -&gt; k_1971&gt;^"lq_tmp_x1975" | k_1974} {VV#1976 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977})^"lq_tmp_x1981" | k_1980}
-&gt; lq_tmp_x1989:{VV#1982 : AssocativeMap.Expr^"lq_tmp_x1984" | k_1983[ds_d1uo:=lq_tmp_x1988]}
-&gt; {VV#1985 : AssocativeMap.Expr^"lq_tmp_x1987" | k_1986[ds_d1uo:=lq_tmp_x1988][i#a1lB:=lq_tmp_x1989]}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2177 : (AssocativeMap.Map {lq_tmp_x2175 : [{lq_tmp_x2172 : GHC.Types.Char^"lq_tmp_x1968" | k_1967[VV#1966:=lq_tmp_x2172][VV#1973:=lq_tmp_x2175][VV#1979:=lq_tmp_x2177]}]&lt;\lq_tmp_x2173 VV -&gt; k_1971[VV#1970:=lq_tmp_x2174][lq_tmp_x1969:=lq_tmp_x2173][VV#1979:=lq_tmp_x2177]&gt;^"lq_tmp_x1975" | k_1974[VV#1973:=lq_tmp_x2175][VV#1979:=lq_tmp_x2177]} {lq_tmp_x2176 : AssocativeMap.Expr^"lq_tmp_x1978" | k_1977[VV#1976:=lq_tmp_x2176][VV#1979:=lq_tmp_x2177]})^"lq_tmp_x1981" | k_1980[VV#1979:=lq_tmp_x2177] &amp;&amp; lq_tmp_x2177 == ds_d1uo}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2178 : AssocativeMap.Expr | lq_tmp_x2178 == e1#a1lJ}</span><span class='hs-varid'>e1</span></a>
</pre>
<p>The above <code>eval</code> seems rather unsafe; whats the guarantee that <code>get x g</code> will succeed? For example, surely trying:</p>

<p>will lead to some unpleasant crash. Shouldn't we <em>check</em> if the variables is present and if not, fail with some sort of <code>Variable Not Bound</code> error? We could, but we can do better: we can prove at compile time, that such errors will not occur.</p>
<p> are those whose values are <em>not</em> bound within an expression, that is, the set of variables that <em>appear</em> in the expression, but are not <em>bound</em> by a dominating <code>Let</code>. We can formalize this notion as a (lifted) function:</p>
<pre><span class=hs-linenum>252: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>free</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>253: </span><span class='hs-definition'>free</span>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>254: </span><a class=annot href="#"><span class=annottext>lq_tmp_x2839:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free lq_tmp_x2839}</span><span class='hs-definition'>free</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a.
{lq_tmp_x2855 : (Data.Set.Base.Set a) | Set_emp lq_tmp_x2855}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>255: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2889:{lq_tmp_x2903 : [{lq_tmp_x2900 : GHC.Types.Char^"lq_tmp_x2892" | k_2891[VV#2890:=lq_tmp_x2900][VV#2897:=lq_tmp_x2903]}]&lt;\lq_tmp_x2901 VV -&gt; k_2895[VV#2894:=lq_tmp_x2902][lq_tmp_x2893:=lq_tmp_x2901]&gt;^"lq_tmp_x2899" | k_2898[VV#2897:=lq_tmp_x2903]}
-&gt; {lq_tmp_x2887 : (Data.Set.Base.Set {lq_tmp_x2903 : [{lq_tmp_x2900 : GHC.Types.Char^"lq_tmp_x2892" | k_2891[VV#2890:=lq_tmp_x2900][VV#2897:=lq_tmp_x2903]}]&lt;\lq_tmp_x2901 VV -&gt; k_2895[VV#2894:=lq_tmp_x2902][lq_tmp_x2893:=lq_tmp_x2901]&gt;^"lq_tmp_x2899" | k_2898[VV#2897:=lq_tmp_x2903]}) | lq_tmp_x2887 == Set_sng lq_tmp_x2889}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2907 : [GHC.Types.Char] | len lq_tmp_x2907 &gt;= 0 &amp;&amp; lq_tmp_x2907 == x#a1lN}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>256: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x2839:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free lq_tmp_x2839}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2933 : AssocativeMap.Expr | lq_tmp_x2933 == e1#a1lO}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2953:(Data.Set.Base.Set {lq_tmp_x2968 : [{lq_tmp_x2965 : GHC.Types.Char^"lq_tmp_x2957" | k_2956[VV#2955:=lq_tmp_x2965][VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x2966 VV -&gt; k_2960[VV#2959:=lq_tmp_x2967][lq_tmp_x2958:=lq_tmp_x2966][lq_tmp_x2952:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x2964" | k_2963[VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]})
-&gt; lq_tmp_x2954:(Data.Set.Base.Set {lq_tmp_x2968 : [{lq_tmp_x2965 : GHC.Types.Char^"lq_tmp_x2957" | k_2956[VV#2955:=lq_tmp_x2965][VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x2966 VV -&gt; k_2960[VV#2959:=lq_tmp_x2967][lq_tmp_x2958:=lq_tmp_x2966][lq_tmp_x2952:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x2964" | k_2963[VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]})
-&gt; {lq_tmp_x2948 : (Data.Set.Base.Set {lq_tmp_x2968 : [{lq_tmp_x2965 : GHC.Types.Char^"lq_tmp_x2957" | k_2956[VV#2955:=lq_tmp_x2965][VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x2966 VV -&gt; k_2960[VV#2959:=lq_tmp_x2967][lq_tmp_x2958:=lq_tmp_x2966][lq_tmp_x2952:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x2964" | k_2963[VV#2962:=lq_tmp_x2968][lq_tmp_x2952:=fix##36#dOrd_a1qR]}) | lq_tmp_x2948 == Set_cup lq_tmp_x2953 lq_tmp_x2954}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x2839:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free lq_tmp_x2839}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2943 : AssocativeMap.Expr | lq_tmp_x2943 == e2#a1lP}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>257: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x2839:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free lq_tmp_x2839}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x3021 : AssocativeMap.Expr | lq_tmp_x3021 == e1#a1lR}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x3103:(Data.Set.Base.Set {lq_tmp_x3118 : [{lq_tmp_x3115 : GHC.Types.Char^"lq_tmp_x3107" | k_3106[VV#3105:=lq_tmp_x3115][VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3116 VV -&gt; k_3110[VV#3109:=lq_tmp_x3117][lq_tmp_x3108:=lq_tmp_x3116][lq_tmp_x3102:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3114" | k_3113[VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]})
-&gt; lq_tmp_x3104:(Data.Set.Base.Set {lq_tmp_x3118 : [{lq_tmp_x3115 : GHC.Types.Char^"lq_tmp_x3107" | k_3106[VV#3105:=lq_tmp_x3115][VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3116 VV -&gt; k_3110[VV#3109:=lq_tmp_x3117][lq_tmp_x3108:=lq_tmp_x3116][lq_tmp_x3102:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3114" | k_3113[VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]})
-&gt; {lq_tmp_x3098 : (Data.Set.Base.Set {lq_tmp_x3118 : [{lq_tmp_x3115 : GHC.Types.Char^"lq_tmp_x3107" | k_3106[VV#3105:=lq_tmp_x3115][VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3116 VV -&gt; k_3110[VV#3109:=lq_tmp_x3117][lq_tmp_x3108:=lq_tmp_x3116][lq_tmp_x3102:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3114" | k_3113[VV#3112:=lq_tmp_x3118][lq_tmp_x3102:=fix##36#dOrd_a1qR]}) | lq_tmp_x3098 == Set_cup lq_tmp_x3103 lq_tmp_x3104}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{lq_tmp_x3133 : (Data.Set.Base.Set {lq_tmp_x3132 : [{lq_tmp_x3129 : GHC.Types.Char^"lq_tmp_x3067" | k_3066[VV#3065:=lq_tmp_x3129][VV#3072:=lq_tmp_x3132][lq_tmp_x3062:=fix##36#dOrd_a1qR][lq_tmp_x3063:=lq_anf__d1we][lq_tmp_x3064:=lq_anf__d1wf][lq_tmp_x3075:=lq_tmp_x3129][lq_tmp_x3078:=lq_tmp_x3132][lq_tmp_x3058:=lq_tmp_x3133]}]&lt;\lq_tmp_x3130 VV -&gt; k_3070[VV#3069:=lq_tmp_x3131][lq_tmp_x3068:=lq_tmp_x3130][lq_tmp_x3062:=fix##36#dOrd_a1qR][lq_tmp_x3063:=lq_anf__d1we][lq_tmp_x3064:=lq_anf__d1wf][lq_tmp_x3077:=lq_tmp_x3131][lq_tmp_x3076:=lq_tmp_x3130][lq_tmp_x3058:=lq_tmp_x3133]&gt;^"lq_tmp_x3074" | k_3073[VV#3072:=lq_tmp_x3132][lq_tmp_x3062:=fix##36#dOrd_a1qR][lq_tmp_x3063:=lq_anf__d1we][lq_tmp_x3064:=lq_anf__d1wf][lq_tmp_x3078:=lq_tmp_x3132][lq_tmp_x3058:=lq_tmp_x3133]}) | lq_tmp_x3133 == Set_dif lq_anf__d1we lq_anf__d1wf &amp;&amp; lq_tmp_x3133 == lq_anf__d1wg}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x2839:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free lq_tmp_x2839}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x3031 : AssocativeMap.Expr | lq_tmp_x3031 == e2#a1lS}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x3063:(Data.Set.Base.Set {lq_tmp_x3078 : [{lq_tmp_x3075 : GHC.Types.Char^"lq_tmp_x3067" | k_3066[VV#3065:=lq_tmp_x3075][VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3076 VV -&gt; k_3070[VV#3069:=lq_tmp_x3077][lq_tmp_x3068:=lq_tmp_x3076][lq_tmp_x3062:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3074" | k_3073[VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]})
-&gt; lq_tmp_x3064:(Data.Set.Base.Set {lq_tmp_x3078 : [{lq_tmp_x3075 : GHC.Types.Char^"lq_tmp_x3067" | k_3066[VV#3065:=lq_tmp_x3075][VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3076 VV -&gt; k_3070[VV#3069:=lq_tmp_x3077][lq_tmp_x3068:=lq_tmp_x3076][lq_tmp_x3062:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3074" | k_3073[VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]})
-&gt; {lq_tmp_x3058 : (Data.Set.Base.Set {lq_tmp_x3078 : [{lq_tmp_x3075 : GHC.Types.Char^"lq_tmp_x3067" | k_3066[VV#3065:=lq_tmp_x3075][VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]}]&lt;\lq_tmp_x3076 VV -&gt; k_3070[VV#3069:=lq_tmp_x3077][lq_tmp_x3068:=lq_tmp_x3076][lq_tmp_x3062:=fix##36#dOrd_a1qR]&gt;^"lq_tmp_x3074" | k_3073[VV#3072:=lq_tmp_x3078][lq_tmp_x3062:=fix##36#dOrd_a1qR]}) | lq_tmp_x3058 == Set_dif lq_tmp_x3063 lq_tmp_x3064}</span><span class='hs-varop'>`difference`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x3035:{lq_tmp_x3049 : [{lq_tmp_x3046 : GHC.Types.Char^"lq_tmp_x3038" | k_3037[VV#3036:=lq_tmp_x3046][VV#3043:=lq_tmp_x3049]}]&lt;\lq_tmp_x3047 VV -&gt; k_3041[VV#3040:=lq_tmp_x3048][lq_tmp_x3039:=lq_tmp_x3047]&gt;^"lq_tmp_x3045" | k_3044[VV#3043:=lq_tmp_x3049]}
-&gt; {lq_tmp_x3033 : (Data.Set.Base.Set {lq_tmp_x3049 : [{lq_tmp_x3046 : GHC.Types.Char^"lq_tmp_x3038" | k_3037[VV#3036:=lq_tmp_x3046][VV#3043:=lq_tmp_x3049]}]&lt;\lq_tmp_x3047 VV -&gt; k_3041[VV#3040:=lq_tmp_x3048][lq_tmp_x3039:=lq_tmp_x3047]&gt;^"lq_tmp_x3045" | k_3044[VV#3043:=lq_tmp_x3049]}) | lq_tmp_x3033 == Set_sng lq_tmp_x3035}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x3053 : [GHC.Types.Char] | len lq_tmp_x3053 &gt;= 0 &amp;&amp; lq_tmp_x3053 == x#a1lQ}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p> with respect to an environment <code>G</code> if all the <em>free</em> variables in the expression appear in <code>G</code>, i.e. the environment contains bindings for all the variables in the expression that are <em>not</em> bound within the expression. As we've seen repeatedly, often a whole pile of informal handwaving, can be succinctly captured by a type definition that says the <code>free</code> variables in the <code>Expr</code> must be contained in the <code>keys</code> of the environment <code>G</code>:</p>
<pre><span class=hs-linenum>269: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>ClosedExpr</span> <span class='hs-conid'>G</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Subset</span> <span class='hs-layout'>(</span><span class='hs-varid'>free</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>G</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p> never goes wrong, i.e. we can ensure that <code>eval</code> will not crash with unbound variables, as long as it is invoked with suitable environments:</p>
<pre><span class=hs-linenum>277: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>eval</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>g</span><span class='hs-conop'>:</span><span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClosedExpr</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>We can be sure an <code>Expr</code> is well-scoped if it has <em>no</em> free variables.Lets use that to write a &quot;top-level&quot; evaluator:</p>
<pre><span class=hs-linenum>284: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>topEval</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Expr</span> <span class='hs-keyword'>| Empty (free v)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>285: </span><a class=annot href="#"><span class=annottext>lq_tmp_x2294:{v : AssocativeMap.Expr | Set_emp free v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>topEval</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2325:(AssocativeMap.Map [GHC.Types.Char] {lq_tmp_x2319 : AssocativeMap.Expr | val lq_tmp_x2319})
-&gt; lq_tmp_x2326:{lq_tmp_x2321 : AssocativeMap.Expr | Set_sub free lq_tmp_x2321 keys lq_tmp_x2325}
-&gt; {lq_tmp_x2322 : AssocativeMap.Expr | val lq_tmp_x2322}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2332 : (AssocativeMap.Map {lq_tmp_x2330 : [{lq_tmp_x2327 : GHC.Types.Char^"lq_tmp_x2298" | k_2297[VV#2296:=lq_tmp_x2327][VV#2303:=lq_tmp_x2330][lq_tmp_x2306:=lq_tmp_x2327][lq_tmp_x2309:=lq_tmp_x2330][lq_tmp_x2295:=lq_tmp_x2332]}]&lt;\lq_tmp_x2328 VV -&gt; k_2301[VV#2300:=lq_tmp_x2329][lq_tmp_x2299:=lq_tmp_x2328][lq_tmp_x2308:=lq_tmp_x2329][lq_tmp_x2307:=lq_tmp_x2328][lq_tmp_x2295:=lq_tmp_x2332]&gt;^"lq_tmp_x2305" | k_2304[VV#2303:=lq_tmp_x2330][lq_tmp_x2309:=lq_tmp_x2330][lq_tmp_x2295:=lq_tmp_x2332]} {lq_tmp_x2331 : AssocativeMap.Expr^"lq_tmp_x2312" | k_2311[VV#2310:=lq_tmp_x2331][lq_tmp_x2313:=lq_tmp_x2331][lq_tmp_x2295:=lq_tmp_x2332]}) | Set_emp keys lq_tmp_x2332 &amp;&amp; lq_tmp_x2332 == lq_anf__d1vU}</span><span class='hs-varid'>emp</span></a> 
</pre>
<p>Complete the definition of the below function which <em>checks</em> if an <code>Expr</code> is well formed before <code>eval</code>uating it:</p>
<pre><span class=hs-linenum>292: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>evalAny</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>293: </span><a class=annot href="#"><span class=annottext>lq_tmp_x2511:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; lq_tmp_x2512:AssocativeMap.Expr
-&gt; (Data.Maybe.Maybe {v : AssocativeMap.Expr | val v})</span><span class='hs-definition'>evalAny</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>AssocativeMap.Expr</span><span class='hs-varid'>e</span></a>
<span class=hs-linenum>294: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2524 : GHC.Types.Bool^"lq_tmp_x2521" "lq_tmp_x2517" "lq_tmp_x21" | k_2520[VV#2519:=lq_tmp_x2524][lq_tmp_x2522:=lq_tmp_x2524] &amp;&amp; k_2516[VV#2515:=lq_tmp_x2524][lq_tmp_x2522:=lq_tmp_x2524] &amp;&amp; lq_tmp_x2524 == lq_anf__d1w2}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2596:{lq_tmp_x2592 : AssocativeMap.Expr^"lq_tmp_x2551" | k_2550[VV#2549:=lq_tmp_x2592][lq_tmp_x2552:=lq_tmp_x2592]}
-&gt; {lq_tmp_x2594 : (Data.Maybe.Maybe {lq_tmp_x2593 : AssocativeMap.Expr^"lq_tmp_x2551" | k_2550[VV#2549:=lq_tmp_x2593][lq_tmp_x2552:=lq_tmp_x2593][lq_tmp_x2546:=lq_tmp_x2594][lq_tmp_x2548:=lq_tmp_x2596]}) | fromJust lq_tmp_x2594 == lq_tmp_x2596 &amp;&amp; isJust lq_tmp_x2594 &lt;=&gt; true}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x2578:(lq_tmp_x2577:{lq_tmp_x2583 : AssocativeMap.Expr^"lq_tmp_x2582" | k_2581[VV#2580:=lq_tmp_x2583]}
              -&gt; {lq_tmp_x2591 : (Data.Maybe.Maybe {lq_tmp_x2590 : AssocativeMap.Expr^"lq_tmp_x2586" | k_2585[VV#2584:=lq_tmp_x2590][VV#2587:=lq_tmp_x2591]})^"lq_tmp_x2589" | k_2588[VV#2587:=lq_tmp_x2591]})
-&gt; lq_tmp_x2579:{lq_tmp_x2583 : AssocativeMap.Expr^"lq_tmp_x2582" | k_2581[VV#2580:=lq_tmp_x2583]}
-&gt; {lq_tmp_x2591 : (Data.Maybe.Maybe {lq_tmp_x2590 : AssocativeMap.Expr^"lq_tmp_x2586" | k_2585[VV#2584:=lq_tmp_x2590][VV#2587:=lq_tmp_x2591]})^"lq_tmp_x2589" | k_2588[VV#2587:=lq_tmp_x2591]}</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x2564:(AssocativeMap.Map [GHC.Types.Char] {lq_tmp_x2558 : AssocativeMap.Expr | val lq_tmp_x2558})
-&gt; lq_tmp_x2565:{lq_tmp_x2560 : AssocativeMap.Expr | Set_sub free lq_tmp_x2560 keys lq_tmp_x2564}
-&gt; {lq_tmp_x2561 : AssocativeMap.Expr | val lq_tmp_x2561}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2571 : (AssocativeMap.Map [GHC.Types.Char] {lq_tmp_x2570 : AssocativeMap.Expr | val lq_tmp_x2570}) | lq_tmp_x2571 == g#a1lT}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2572 : AssocativeMap.Expr | lq_tmp_x2572 == e#a1lU}</span><span class='hs-varid'>e</span></a>
<span class=hs-linenum>295: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2535 : (Data.Maybe.Maybe {lq_tmp_x2539 : AssocativeMap.Expr^"lq_tmp_x2538" | k_2537[VV#2536:=lq_tmp_x2539]}) | isJust lq_tmp_x2535 &lt;=&gt; false}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>296: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>297: </span>    <a class=annot href="#"><span class=annottext>forall t. {VV#2515 : t^"lq_tmp_x2517" "lq_tmp_x21" | k_2516}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV#2515 : t^"lq_tmp_x2517" "lq_tmp_x21" | k_2516}</span><span class='hs-varid'>undefined</span></a>  
</pre>
<p>Proof is all well and good, in the end, you need a few sanity tests to kick the tires. So:</p>
<pre><span class=hs-linenum>304: </span><a class=annot href="#"><span class=annottext>[AssocativeMap.Expr^"lq_tmp_x168"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x170"</span><span class='hs-definition'>tests</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2509 : [{lq_tmp_x2506 : AssocativeMap.Expr^"lq_tmp_x2475" | k_2474[VV#2473:=lq_tmp_x2506][lq_tmp_x2471:=v2#a1lX][lq_tmp_x2472:=lq_anf__d1w0][lq_tmp_x2476:=lq_tmp_x2506][lq_tmp_x2468:=lq_tmp_x2509]}]&lt;\lq_tmp_x2507 VV -&gt; k_2478[lq_tmp_x2480:=lq_tmp_x2507][VV#2477:=lq_tmp_x2508][lq_tmp_x2471:=v2#a1lX][lq_tmp_x2472:=lq_anf__d1w0][lq_tmp_x2476:=lq_tmp_x2508][lq_tmp_x2467:=lq_tmp_x2507]&gt; | listElts lq_tmp_x2509 == Set_cup Set_sng v2#a1lX listElts lq_anf__d1w0 &amp;&amp; null lq_tmp_x2509 &lt;=&gt; false &amp;&amp; len lq_tmp_x2509 == 1 + len lq_anf__d1w0 &amp;&amp; xsListSelector lq_tmp_x2509 == lq_anf__d1w0 &amp;&amp; xListSelector lq_tmp_x2509 == v2#a1lX &amp;&amp; elems lq_tmp_x2509 == Set_cup Set_sng v2#a1lX elems lq_anf__d1w0 &amp;&amp; len lq_tmp_x2509 &gt;= 0 &amp;&amp; lq_tmp_x2509 == lq_anf__d1w1}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x2505 : AssocativeMap.Expr | val lq_tmp_x2505 &amp;&amp; lq_tmp_x2505 == v1#a1lW}</span><span class='hs-varid'>v1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2482 : AssocativeMap.Expr | val lq_tmp_x2482 &amp;&amp; lq_tmp_x2482 == v2#a1lX}</span><span class='hs-varid'>v2</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>305: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>306: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2448 : AssocativeMap.Expr | val lq_tmp_x2448}</span><span class='hs-varid'>v1</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2450:{lq_tmp_x2447 : AssocativeMap.Expr | Set_emp free lq_tmp_x2447}
-&gt; {lq_tmp_x2448 : AssocativeMap.Expr | val lq_tmp_x2448}</span><span class='hs-varid'>topEval</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp_x2451 : AssocativeMap.Expr | free lq_tmp_x2451 == Set_cup free lq_anf__d1vZ free c1#a1m1 &amp;&amp; val lq_tmp_x2451 &lt;=&gt; false &amp;&amp; lq_tmp_x2451 == e1#a1lY}</span><span class='hs-varid'>e1</span></a></span>          <span class='hs-comment'>-- Rejected by LH</span>
<span class=hs-linenum>307: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2442 : AssocativeMap.Expr | val lq_tmp_x2442}</span><span class='hs-varid'>v2</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2444:{lq_tmp_x2441 : AssocativeMap.Expr | Set_emp free lq_tmp_x2441}
-&gt; {lq_tmp_x2442 : AssocativeMap.Expr | val lq_tmp_x2442}</span><span class='hs-varid'>topEval</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2445 : AssocativeMap.Expr | free lq_tmp_x2445 == Set_cup free c10#a1m2 Set_dif free e1#a1lY Set_sng x#a1m0 &amp;&amp; val lq_tmp_x2445 &lt;=&gt; false &amp;&amp; lq_tmp_x2445 == e2#a1lZ}</span><span class='hs-varid'>e2</span></a>          <span class='hs-comment'>-- Accepted by LH</span>
<span class=hs-linenum>308: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2413 : AssocativeMap.Expr | free lq_tmp_x2413 == Set_cup free lq_anf__d1vZ free c1#a1m1 &amp;&amp; val lq_tmp_x2413 &lt;=&gt; false}</span><span class='hs-varid'>e1</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x2405:[GHC.Types.Char]
-&gt; {lq_tmp_x2403 : AssocativeMap.Expr | free lq_tmp_x2403 == Set_sng lq_tmp_x2405 &amp;&amp; val lq_tmp_x2403 &lt;=&gt; false}</span><span class='hs-conid'>Var</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2409 : [{lq_tmp_x2406 : GHC.Types.Char^"lq_tmp_x2386" | k_2385[VV#2384:=lq_tmp_x2406][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY][lq_tmp_x2387:=lq_tmp_x2406][lq_tmp_x2379:=lq_tmp_x2409]}]&lt;\lq_tmp_x2407 VV -&gt; k_2389[lq_tmp_x2391:=lq_tmp_x2407][VV#2388:=lq_tmp_x2408][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY][lq_tmp_x2387:=lq_tmp_x2408][lq_tmp_x2378:=lq_tmp_x2407]&gt; | listElts lq_tmp_x2409 == Set_cup Set_sng lq_anf__d1vX listElts lq_anf__d1vY &amp;&amp; null lq_tmp_x2409 &lt;=&gt; false &amp;&amp; len lq_tmp_x2409 == 1 + len lq_anf__d1vY &amp;&amp; xsListSelector lq_tmp_x2409 == lq_anf__d1vY &amp;&amp; xListSelector lq_tmp_x2409 == lq_anf__d1vX &amp;&amp; elems lq_tmp_x2409 == Set_cup Set_sng lq_anf__d1vX elems lq_anf__d1vY &amp;&amp; len lq_tmp_x2409 &gt;= 0 &amp;&amp; lq_tmp_x2409 == x#a1m0}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2416:AssocativeMap.Expr
-&gt; lq_tmp_x2417:AssocativeMap.Expr
-&gt; {lq_tmp_x2413 : AssocativeMap.Expr | free lq_tmp_x2413 == Set_cup free lq_tmp_x2416 free lq_tmp_x2417 &amp;&amp; val lq_tmp_x2413 &lt;=&gt; false}</span><span class='hs-varop'>`Plus`</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2419 : AssocativeMap.Expr | free lq_tmp_x2419 == Set_empty 0 &amp;&amp; val lq_tmp_x2419 &lt;=&gt; true &amp;&amp; lq_tmp_x2419 == c1#a1m1}</span><span class='hs-varid'>c1</span></a> 
<span class=hs-linenum>309: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2427 : AssocativeMap.Expr | free lq_tmp_x2427 == Set_cup free c10#a1m2 Set_dif free e1#a1lY Set_sng x#a1m0 &amp;&amp; val lq_tmp_x2427 &lt;=&gt; false}</span><span class='hs-varid'>e2</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2431:[GHC.Types.Char]
-&gt; lq_tmp_x2432:AssocativeMap.Expr
-&gt; lq_tmp_x2433:AssocativeMap.Expr
-&gt; {lq_tmp_x2427 : AssocativeMap.Expr | free lq_tmp_x2427 == Set_cup free lq_tmp_x2432 Set_dif free lq_tmp_x2433 Set_sng lq_tmp_x2431 &amp;&amp; val lq_tmp_x2427 &lt;=&gt; false}</span><span class='hs-conid'>Let</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2437 : [{lq_tmp_x2434 : GHC.Types.Char^"lq_tmp_x2386" | k_2385[VV#2384:=lq_tmp_x2434][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY][lq_tmp_x2387:=lq_tmp_x2434][lq_tmp_x2379:=lq_tmp_x2437]}]&lt;\lq_tmp_x2435 VV -&gt; k_2389[lq_tmp_x2391:=lq_tmp_x2435][VV#2388:=lq_tmp_x2436][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY][lq_tmp_x2387:=lq_tmp_x2436][lq_tmp_x2378:=lq_tmp_x2435]&gt; | listElts lq_tmp_x2437 == Set_cup Set_sng lq_anf__d1vX listElts lq_anf__d1vY &amp;&amp; null lq_tmp_x2437 &lt;=&gt; false &amp;&amp; len lq_tmp_x2437 == 1 + len lq_anf__d1vY &amp;&amp; xsListSelector lq_tmp_x2437 == lq_anf__d1vY &amp;&amp; xListSelector lq_tmp_x2437 == lq_anf__d1vX &amp;&amp; elems lq_tmp_x2437 == Set_cup Set_sng lq_anf__d1vX elems lq_anf__d1vY &amp;&amp; len lq_tmp_x2437 &gt;= 0 &amp;&amp; lq_tmp_x2437 == x#a1m0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2438 : AssocativeMap.Expr | free lq_tmp_x2438 == Set_empty 0 &amp;&amp; val lq_tmp_x2438 &lt;=&gt; true &amp;&amp; lq_tmp_x2438 == c10#a1m2}</span><span class='hs-varid'>c10</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2439 : AssocativeMap.Expr | free lq_tmp_x2439 == Set_cup free lq_anf__d1vZ free c1#a1m1 &amp;&amp; val lq_tmp_x2439 &lt;=&gt; false &amp;&amp; lq_tmp_x2439 == e1#a1lY}</span><span class='hs-varid'>e1</span></a> 
<span class=hs-linenum>310: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2379 : [{lq_tmp_x2387 : GHC.Types.Char^"lq_tmp_x2386" | k_2385[VV#2384:=lq_tmp_x2387][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY]}]&lt;\lq_tmp_x2378 VV -&gt; k_2389[lq_tmp_x2391:=lq_tmp_x2378][VV#2388:=lq_tmp_x2387][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY]&gt; | listElts lq_tmp_x2379 == Set_cup Set_sng lq_anf__d1vX listElts lq_anf__d1vY &amp;&amp; null lq_tmp_x2379 &lt;=&gt; false &amp;&amp; len lq_tmp_x2379 == 1 + len lq_anf__d1vY &amp;&amp; xsListSelector lq_tmp_x2379 == lq_anf__d1vY &amp;&amp; xListSelector lq_tmp_x2379 == lq_anf__d1vX &amp;&amp; elems lq_tmp_x2379 == Set_cup Set_sng lq_anf__d1vX elems lq_anf__d1vY}</span><span class='hs-varid'>x</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x2379 : [{lq_tmp_x2387 : GHC.Types.Char^"lq_tmp_x2386" | k_2385[VV#2384:=lq_tmp_x2387][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY]}]&lt;\lq_tmp_x2378 VV -&gt; k_2389[lq_tmp_x2391:=lq_tmp_x2378][VV#2388:=lq_tmp_x2387][lq_tmp_x2382:=lq_anf__d1vX][lq_tmp_x2383:=lq_anf__d1vY]&gt; | listElts lq_tmp_x2379 == Set_cup Set_sng lq_anf__d1vX listElts lq_anf__d1vY &amp;&amp; null lq_tmp_x2379 &lt;=&gt; false &amp;&amp; len lq_tmp_x2379 == 1 + len lq_anf__d1vY &amp;&amp; xsListSelector lq_tmp_x2379 == lq_anf__d1vY &amp;&amp; xListSelector lq_tmp_x2379 == lq_anf__d1vX &amp;&amp; elems lq_tmp_x2379 == Set_cup Set_sng lq_anf__d1vX elems lq_anf__d1vY}</span><span class='hs-str'>"x"</span></a>
<span class=hs-linenum>311: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2353 : AssocativeMap.Expr | free lq_tmp_x2353 == Set_empty 0 &amp;&amp; val lq_tmp_x2353 &lt;=&gt; true}</span><span class='hs-varid'>c1</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2355:GHC.Types.Int
-&gt; {lq_tmp_x2353 : AssocativeMap.Expr | free lq_tmp_x2353 == Set_empty 0 &amp;&amp; val lq_tmp_x2353 &lt;=&gt; true}</span><span class='hs-conid'>Const</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2356 : GHC.Types.Int | lq_tmp_x2356 == (1  :  int) &amp;&amp; lq_tmp_x2356 == lq_anf__d1vW}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>312: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp_x2341 : AssocativeMap.Expr | free lq_tmp_x2341 == Set_empty 0 &amp;&amp; val lq_tmp_x2341 &lt;=&gt; true}</span><span class='hs-varid'>c10</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x2343:GHC.Types.Int
-&gt; {lq_tmp_x2341 : AssocativeMap.Expr | free lq_tmp_x2341 == Set_empty 0 &amp;&amp; val lq_tmp_x2341 &lt;=&gt; true}</span><span class='hs-conid'>Const</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x2344 : GHC.Types.Int | lq_tmp_x2344 == (10  :  int) &amp;&amp; lq_tmp_x2344 == lq_anf__d1vV}</span><span class='hs-num'>10</span></a>
</pre>
<p> Extend the language above to include functions. That is, extend</p>
<pre><span class=hs-linenum>319: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varop'>...</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Fun</span> <span class='hs-conid'>Var</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
</pre>
<p>Just focus on ensuring the safety of variable lookups; ensuring full type-safety (i.e. every application is to a function) is rather more complicated and beyond the scope of what we've seen so far.</p>
<h2 id="implementing-maps-binary-search-trees">Implementing Maps: Binary Search Trees</h2>
<p>We just saw how easy it is to <em>use</em> the Associative Map <a href="#mapapi">API</a> to ensure the safety of lookups, even though the <code>Map</code> has a &quot;dynamically&quot; generated set of keys. Next, lets see how we can <em>implement</em> a <code>Map</code> library that respects the API using <a href="#binarysearchtree">Binary Search Trees</a></p>
<p> First, lets provide an implementation of the (hitherto abstract) data type for <code>Map</code>. We shall use Binary Search Trees, wherein, at each <code>Node</code>, the <code>left</code> (resp. <code>right</code>) subtree has keys that are less than (resp. greater than) the root <code>key</code>.</p>
<pre><span class=hs-linenum>346: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <span class='hs-varid'>key</span>   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>347: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>value</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>348: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>left</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>key</span><span class='hs-layout'>}</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>349: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>key</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-varid'>v</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>350: </span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Tip</span> 
<span class=hs-linenum>351: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>(#binarysearchtree) that the above refined data definition yields strengthened data constructors that statically ensure that only legal, <em>binary-search ordered</em> trees are created in the program.</p>
<p> Next, we must provide an implementation of the notion of the <code>keys</code> that are defined for a given <code>Map</code>. This is achieved via the (lifted) measure function:</p>
<pre><span class=hs-linenum>365: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>keys</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>366: </span><span class='hs-definition'>keys</span>                <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>367: </span><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x986:(AssocativeMap.Map k v)
-&gt; {VV : (Data.Set.Base.Set k) | VV == keys lq_tmp_x986}</span><span class='hs-definition'>keys</span></a> <span class='hs-conid'>Tip</span>            <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a.
{lq_tmp_x1094 : (Data.Set.Base.Set a) | Set_emp lq_tmp_x1094}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>368: </span><span class='hs-definition'>keys</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1081:(Data.Set.Base.Set {VV#1083 : k^"lq_tmp_x1085" | k_1084[lq_tmp_x1080:=fix##36#dOrd_a1qy]})
-&gt; lq_tmp_x1082:(Data.Set.Base.Set {VV#1083 : k^"lq_tmp_x1085" | k_1084[lq_tmp_x1080:=fix##36#dOrd_a1qy]})
-&gt; {lq_tmp_x1076 : (Data.Set.Base.Set {VV#1083 : k^"lq_tmp_x1085" | k_1084[lq_tmp_x1080:=fix##36#dOrd_a1qy]}) | lq_tmp_x1076 == Set_cup lq_tmp_x1081 lq_tmp_x1082}</span><span class='hs-varid'>union</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1019:{VV#1020 : k^"lq_tmp_x1022" | k_1021}
-&gt; {lq_tmp_x1017 : (Data.Set.Base.Set {VV#1020 : k^"lq_tmp_x1022" | k_1021}) | lq_tmp_x1017 == Set_sng lq_tmp_x1019}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1m3}</span><span class='hs-varid'>k</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1064:(Data.Set.Base.Set {VV#1066 : k^"lq_tmp_x1068" | k_1067[lq_tmp_x1063:=fix##36#dOrd_a1qy]})
-&gt; lq_tmp_x1065:(Data.Set.Base.Set {VV#1066 : k^"lq_tmp_x1068" | k_1067[lq_tmp_x1063:=fix##36#dOrd_a1qy]})
-&gt; {lq_tmp_x1059 : (Data.Set.Base.Set {VV#1066 : k^"lq_tmp_x1068" | k_1067[lq_tmp_x1063:=fix##36#dOrd_a1qy]}) | lq_tmp_x1059 == Set_cup lq_tmp_x1064 lq_tmp_x1065}</span><span class='hs-varid'>union</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x986:(AssocativeMap.Map k v)
-&gt; {VV : (Data.Set.Base.Set k) | VV == keys lq_tmp_x986}</span><span class='hs-varid'>keys</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1038 : (AssocativeMap.Map {VV : k | VV &lt; k#a1m3} v) | lq_tmp_x1038 == l#a1m4}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x986:(AssocativeMap.Map k v)
-&gt; {VV : (Data.Set.Base.Set k) | VV == keys lq_tmp_x986}</span><span class='hs-varid'>keys</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1054 : (AssocativeMap.Map {VV : k | k#a1m3 &lt; VV} v) | lq_tmp_x1054 == r#a1m5}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>Armed with the basic type and measure definition, we can start to fill in the operations for <code>Maps</code>.</p>
<p> To make sure you are following, fill in the definition for an <code>emp</code>ty Map:</p>
<pre><span class=hs-linenum>378: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>emp</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{m:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>| NoKey m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>379: </span><a class=annot href="#"><span class=annottext>forall k v. {m : (AssocativeMap.Map k v) | Set_emp keys m}</span><span class='hs-definition'>emp</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. a^"lq_tmp_x21"</span><span class='hs-varid'>undefined</span></a>  
</pre>
<p> To add a key <code>k'</code> to a <code>Map</code> we recursively traverse the <code>Map</code> zigging <code>left</code> or <code>right</code> depending on the result of comparisons with the keys along the path. Unfortunately, the version below has an (all too common!) bug, and hence, is <em>rejected</em> by LiquidHaskell. Find and fix the bug so that the function is verified.</p>
<pre><span class=hs-linenum>391: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>set</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>| PlusKey k m n}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>392: </span><span class=hs-error><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x764:k
-&gt; lq_tmp_x765:v
-&gt; lq_tmp_x766:(AssocativeMap.Map k v)
-&gt; {n : (AssocativeMap.Map k v) | keys n == Set_cup Set_sng lq_tmp_x764 keys lq_tmp_x766}</span><span class='hs-definition'>set</span></a></span> <a class=annot href="#"><span class=annottext>k</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>v</span><span class='hs-varid'>v'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>393: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1m6}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x814:{VV#816 : k^"lq_tmp_x818" | k_817[lq_tmp_x813:=fix##36#dEq_a1qe]}
-&gt; lq_tmp_x815:{VV#816 : k^"lq_tmp_x818" | k_817[lq_tmp_x813:=fix##36#dEq_a1qe]}
-&gt; {lq_tmp_x809 : GHC.Types.Bool | Prop lq_tmp_x809 &lt;=&gt; lq_tmp_x814 == lq_tmp_x815}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1m8}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x922:{VV#926 : k^"lq_tmp_x928" | k_927}
-&gt; lq_tmp_x923:{VV#929 : v^"lq_tmp_x931" | k_930}
-&gt; lq_tmp_x924:(AssocativeMap.Map {VV#926 : k^"lq_tmp_x928" | k_927 &amp;&amp; VV#926 &lt; lq_tmp_x922} {VV#929 : v^"lq_tmp_x931" | k_930})
-&gt; lq_tmp_x925:(AssocativeMap.Map {VV#926 : k^"lq_tmp_x928" | k_927 &amp;&amp; lq_tmp_x922 &lt; VV#926} {VV#929 : v^"lq_tmp_x931" | k_930})
-&gt; {lq_tmp_x917 : (AssocativeMap.Map {VV#926 : k^"lq_tmp_x928" | k_927} {VV#929 : v^"lq_tmp_x931" | k_930}) | right lq_tmp_x917 == lq_tmp_x925 &amp;&amp; left lq_tmp_x917 == lq_tmp_x924 &amp;&amp; value lq_tmp_x917 == lq_tmp_x923 &amp;&amp; key lq_tmp_x917 == lq_tmp_x922 &amp;&amp; keys lq_tmp_x917 == Set_cup Set_sng lq_tmp_x922 Set_cup keys lq_tmp_x924 keys lq_tmp_x925}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1m8}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{VV : v | VV == v'#a1m7}</span><span class='hs-varid'>v'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x932 : (AssocativeMap.Map {VV : k | VV &lt; k#a1m8} v) | lq_tmp_x932 == l#a1ma}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x933 : (AssocativeMap.Map {VV : k | k#a1m8 &lt; VV} v) | lq_tmp_x933 == r#a1mb}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>394: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1m6}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x847:{VV#849 : k^"lq_tmp_x851" | k_850[lq_tmp_x846:=fix##36#dOrd_a1qb]}
-&gt; lq_tmp_x848:{VV#849 : k^"lq_tmp_x851" | k_850[lq_tmp_x846:=fix##36#dOrd_a1qb]}
-&gt; {lq_tmp_x842 : GHC.Types.Bool | Prop lq_tmp_x842 &lt;=&gt; lq_tmp_x847 &lt; lq_tmp_x848}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1m8}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x764:k
-&gt; lq_tmp_x765:v
-&gt; lq_tmp_x766:(AssocativeMap.Map k v)
-&gt; {n : (AssocativeMap.Map k v) | keys n == Set_cup Set_sng lq_tmp_x764 keys lq_tmp_x766}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1m6}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : v | VV == v#a1m9}</span><span class='hs-varid'>v</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x908 : (AssocativeMap.Map {VV : k | VV &lt; k#a1m8} v) | lq_tmp_x908 == l#a1ma}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>395: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x764:k
-&gt; lq_tmp_x765:v
-&gt; lq_tmp_x766:(AssocativeMap.Map k v)
-&gt; {n : (AssocativeMap.Map k v) | keys n == Set_cup Set_sng lq_tmp_x764 keys lq_tmp_x766}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1m6}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : v | VV == v#a1m9}</span><span class='hs-varid'>v</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x883 : (AssocativeMap.Map {VV : k | k#a1m8 &lt; VV} v) | lq_tmp_x883 == r#a1mb}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>396: </span><span class='hs-definition'>set</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>v'</span> <span class='hs-conid'>Tip</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x962:{VV#966 : k^"lq_tmp_x968" | k_967}
-&gt; lq_tmp_x963:{VV#969 : v^"lq_tmp_x971" | k_970}
-&gt; lq_tmp_x964:(AssocativeMap.Map {VV#966 : k^"lq_tmp_x968" | k_967 &amp;&amp; VV#966 &lt; lq_tmp_x962} {VV#969 : v^"lq_tmp_x971" | k_970})
-&gt; lq_tmp_x965:(AssocativeMap.Map {VV#966 : k^"lq_tmp_x968" | k_967 &amp;&amp; lq_tmp_x962 &lt; VV#966} {VV#969 : v^"lq_tmp_x971" | k_970})
-&gt; {lq_tmp_x957 : (AssocativeMap.Map {VV#966 : k^"lq_tmp_x968" | k_967} {VV#969 : v^"lq_tmp_x971" | k_970}) | right lq_tmp_x957 == lq_tmp_x965 &amp;&amp; left lq_tmp_x957 == lq_tmp_x964 &amp;&amp; value lq_tmp_x957 == lq_tmp_x963 &amp;&amp; key lq_tmp_x957 == lq_tmp_x962 &amp;&amp; keys lq_tmp_x957 == Set_cup Set_sng lq_tmp_x962 Set_cup keys lq_tmp_x964 keys lq_tmp_x965}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1m6}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : v | VV == v'#a1m7}</span><span class='hs-varid'>v'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x972 : (AssocativeMap.Map {VV#940 : k^"lq_tmp_x942" | k_941[lq_tmp_x939:=lq_tmp_x972]} {VV#943 : v^"lq_tmp_x945" | k_944[lq_tmp_x939:=lq_tmp_x972]}) | keys lq_tmp_x972 == Set_empty 0 &amp;&amp; lq_tmp_x972 == lq_anf__d1va}</span><span class='hs-conid'>Tip</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x973 : (AssocativeMap.Map {VV#948 : k^"lq_tmp_x950" | k_949[lq_tmp_x947:=lq_tmp_x973]} {VV#951 : v^"lq_tmp_x953" | k_952[lq_tmp_x947:=lq_tmp_x973]}) | keys lq_tmp_x973 == Set_empty 0 &amp;&amp; lq_tmp_x973 == lq_anf__d1vb}</span><span class='hs-conid'>Tip</span></a>
</pre>
<p> Next, lets write the <code>mem</code> function that returns the value associated with a key <code>k'</code>. To do so we just compare <code>k'</code> with the root key, if they are equal, we return the binding, and otherwise we go down the <code>left</code> (resp. <code>right</code>) subtree if sought for key is less (resp. greater) than the root <code>key</code>. Crucially, we want to check that lookup <em>never fails</em>, and hence, we implement the <code>Tip</code> (i.e. empty) case with <code>die</code> gets LiquidHaskell to prove that that case is indeed dead code, i.e. never happens at run-time.</p>
<pre><span class=hs-linenum>409: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>get'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>  <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Map k v | HasKey k m}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>410: </span><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1512:k
-&gt; lq_tmp_x1513:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1512 keys m}
-&gt; v</span><span class='hs-definition'>get'</span></a> <a class=annot href="#"><span class=annottext>k</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{m : (AssocativeMap.Map k v) | Set_mem k'#a1me keys m}</span><span class='hs-varid'>m</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>411: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1me}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1560:{VV#1562 : k^"lq_tmp_x1564" | k_1563[lq_tmp_x1559:=fix##36#dEq_a1rp]}
-&gt; lq_tmp_x1561:{VV#1562 : k^"lq_tmp_x1564" | k_1563[lq_tmp_x1559:=fix##36#dEq_a1rp]}
-&gt; {lq_tmp_x1555 : GHC.Types.Bool | Prop lq_tmp_x1555 &lt;=&gt; lq_tmp_x1560 == lq_tmp_x1561}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mg}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : v | VV == v#a1mh}</span><span class='hs-varid'>v</span></a>
<span class=hs-linenum>412: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1me}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1587:{VV#1589 : k^"lq_tmp_x1591" | k_1590[lq_tmp_x1586:=fix##36#dOrd_a1rm]}
-&gt; lq_tmp_x1588:{VV#1589 : k^"lq_tmp_x1591" | k_1590[lq_tmp_x1586:=fix##36#dOrd_a1rm]}
-&gt; {lq_tmp_x1582 : GHC.Types.Bool | Prop lq_tmp_x1582 &lt;=&gt; lq_tmp_x1587 &lt; lq_tmp_x1588}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mg}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1512:k
-&gt; lq_tmp_x1513:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1512 keys m}
-&gt; v</span><span class='hs-varid'>get'</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1me}</span><span class='hs-varid'>k'</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp_x1642 : (AssocativeMap.Map {VV : k | VV &lt; k#a1mg} v) | lq_tmp_x1642 == l#a1mi}</span><span class='hs-varid'>l</span></a></span>
<span class=hs-linenum>413: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1512:k
-&gt; lq_tmp_x1513:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1512 keys m}
-&gt; v</span><span class='hs-varid'>get'</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1me}</span><span class='hs-varid'>k'</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp_x1620 : (AssocativeMap.Map {VV : k | k#a1mg &lt; VV} v) | lq_tmp_x1620 == r#a1mj}</span><span class='hs-varid'>r</span></a></span>
<span class=hs-linenum>414: </span><span class='hs-definition'>get'</span>  <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1668:{lq_tmp_x1666 : [GHC.Types.Char] | false}
-&gt; {VV#1669 : v^"lq_tmp_x1671" | k_1670}</span><span class='hs-varid'>die</span></a>  <a class=annot href="#"><span class=annottext>{lq_tmp_x1675 : [GHC.Types.Char^"lq_tmp_x10"]&lt;\lq_tmp_x1673 VV -&gt; True&gt;^"lq_tmp_x12" | len lq_tmp_x1675 &gt;= 0 &amp;&amp; lq_tmp_x1675 == lq_anf__d1vE}</span><span class='hs-str'>"Lookup Never Fails"</span></a>
</pre>
<p> the function above is <em>rejected</em> by LiquidHaskell. This is a puzzler (and a bummer!) because in fact it <em>is</em> correct. So what gives? Well, lets look at the error for the call <code>get' k' l</code></p>

<p>LiquidHaskell is <em>unable</em> to deduce that the the key <code>k'</code> definitely belongs in the <code>left</code> subtree <code>l</code>. Well, lets ask ourselves: <em>why</em> must <code>k'</code> belong in the left subtree? From the input, we know <code>HasKey k' m</code> i.e. that <code>k'</code> is <em>somewhere</em> in <code>m</code>. That is <em>one of</em> the following holds:</p>
<ol style="list-style-type: decimal">
<li><code>k' == k</code> or,</li>
<li><code>HasKey k' l</code> or,</li>
<li><code>HasKey k' r</code>.</li>
</ol>
<p>As the preceding guard <code>k' == k</code> fails, we (and LiquidHaskell) can rule out case (1). Now, what about the <code>Map</code> tells us that case (2) must hold, i.e. that case (3) cannot hold? The <em>BST invariant</em>, all keys in <code>r</code> exceed <code>k</code> which itself exceeds <code>k'</code>. That is, all nodes in <code>r</code> are <em>disequal</em> to <code>k'</code> and hence <code>k'</code> cannot be in <code>r</code>, ruling out case (3). Formally, we need the fact that: <br /><span class="math">$$\forall\ \vkey,\ \vt. \vt :: {\vMap\ \reft{\vkey'}{k}{\vkey' \not = \vkey}\ v}
                        \ \Rightarrow\
                        \lnot (\vHasKey\ \vkey\ \vt)$$</span><br /></p>
<p> Unfortunately, LiquidHaskell <em>cannot automatically</em> deduce facts like the above, as they relate refinements of a container's <em>type parameters</em> (here: <span class="math">$\vkey' \not = \vkey$</span>, which refines the <code>Map</code>s first type parameter) with properties of the entire container (here: <span class="math">$\vHasKey\ \vkey\ \vt$</span>).  Fortunately, it is both easy to <em>state</em>, <em>prove</em> and <em>use</em> facts like the above.</p>
<p> To state a lemma, we need only convert it into a <a href="curry-howard">type</a> by viewing universal quantifiers as function parameters, and implications as function types:</p>
<pre><span class=hs-linenum>476: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lemma_notMem</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>key</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-keyword'>{k:</span><span class='hs-definition'>k</span> <span class='hs-keyword'>| k /= key}</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| not (HasKey key m)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>477: </span><a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x688:k
-&gt; lq_tmp_x689:(AssocativeMap.Map {VV : k | VV /= lq_tmp_x688} v)
-&gt; {v : GHC.Types.Bool | not (Set_mem lq_tmp_x688 keys lq_tmp_x689)}</span><span class='hs-definition'>lemma_notMem</span></a> <span class='hs-keyword'>_</span>   <span class='hs-conid'>Tip</span>            <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x762 : GHC.Types.Bool | Prop lq_tmp_x762 &amp;&amp; lq_tmp_x762 == GHC.Types.True#6u}</span><span class='hs-conid'>True</span></a> 
<span class=hs-linenum>478: </span><span class='hs-definition'>lemma_notMem</span> <span class='hs-varid'>key</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x688:k
-&gt; lq_tmp_x689:(AssocativeMap.Map {VV : k | VV /= lq_tmp_x688} v)
-&gt; {v : GHC.Types.Bool | not (Set_mem lq_tmp_x688 keys lq_tmp_x689)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == ds_d1tQ}</span><span class='hs-varid'>key</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x732 : (AssocativeMap.Map {VV : k | VV /= ds_d1tQ &amp;&amp; VV &lt; ds_d1tS} v) | lq_tmp_x732 == l#a1ml}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x753:GHC.Types.Bool
-&gt; lq_tmp_x754:GHC.Types.Bool
-&gt; {lq_tmp_x750 : GHC.Types.Bool | Prop lq_tmp_x750 &lt;=&gt; Prop lq_tmp_x753 &amp;&amp; Prop lq_tmp_x754}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x688:k
-&gt; lq_tmp_x689:(AssocativeMap.Map {VV : k | VV /= lq_tmp_x688} v)
-&gt; {v : GHC.Types.Bool | not (Set_mem lq_tmp_x688 keys lq_tmp_x689)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == ds_d1tQ}</span><span class='hs-varid'>key</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x746 : (AssocativeMap.Map {VV : k | VV /= ds_d1tQ &amp;&amp; ds_d1tS &lt; VV} v) | lq_tmp_x746 == r#a1mm}</span><span class='hs-varid'>r</span></a> 
</pre>
<p> Note how the signature for <code>lemma_notMem</code> corresponds exactly to the missing fact from above. The &quot;output&quot; type is a <code>Bool</code> refined with the proposition that we desire. We <em>prove</em> the lemma simply by <em>traversing</em> the tree which lets LiquidHaskell build up a proof for the output fact by inductively combining the proofs from the subtrees.</p>
<p> To use a lemma, we need to <em>instantiate</em> it to the particular keys and trees we care about, by &quot;calling&quot; the lemma function, and forcing its result to be in the <em>environment</em> used to typecheck the expression where we want to use the lemma. Say what? Here is a verified <code>get</code>:</p>
<pre><span class=hs-linenum>495: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>get</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Map k v | HasKey k m}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>496: </span><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1677:k
-&gt; lq_tmp_x1678:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1677 keys m}
-&gt; v</span><span class='hs-definition'>get</span></a> <a class=annot href="#"><span class=annottext>k</span><span class='hs-varid'>k'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>497: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1725:{VV#1727 : k^"lq_tmp_x1729" | k_1728[lq_tmp_x1724:=fix##36#dEq_a1rD]}
-&gt; lq_tmp_x1726:{VV#1727 : k^"lq_tmp_x1729" | k_1728[lq_tmp_x1724:=fix##36#dEq_a1rD]}
-&gt; {lq_tmp_x1720 : GHC.Types.Bool | Prop lq_tmp_x1720 &lt;=&gt; lq_tmp_x1725 == lq_tmp_x1726}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mo}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : v | VV == v#a1mp}</span><span class='hs-varid'>v</span></a>
<span class=hs-linenum>498: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1752:{VV#1754 : k^"lq_tmp_x1756" | k_1755[lq_tmp_x1751:=fix##36#dOrd_a1rA]}
-&gt; lq_tmp_x1753:{VV#1754 : k^"lq_tmp_x1756" | k_1755[lq_tmp_x1751:=fix##36#dOrd_a1rA]}
-&gt; {lq_tmp_x1747 : GHC.Types.Bool | Prop lq_tmp_x1747 &lt;=&gt; lq_tmp_x1752 &lt; lq_tmp_x1753}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mo}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1853:{lq_tmp_x1858 : GHC.Types.Bool^"lq_tmp_x1857" "lq_tmp_x164" | k_1856[VV#1855:=lq_tmp_x1858]}
-&gt; lq_tmp_x1854:{VV#1859 : v^"lq_tmp_x1861" "lq_tmp_x166" | k_1860}
-&gt; {VV#1859 : v^"lq_tmp_x1861" "lq_tmp_x167" | k_1860}</span><span class='hs-varid'>assert</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x688:k
-&gt; lq_tmp_x689:(AssocativeMap.Map {VV : k | VV /= lq_tmp_x688} v)
-&gt; {v : GHC.Types.Bool | not (Set_mem lq_tmp_x688 keys lq_tmp_x689)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1849 : (AssocativeMap.Map {VV : k | k#a1mo &lt; VV} v) | lq_tmp_x1849 == r#a1mr}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1885:(lq_tmp_x1884:{VV#1887 : v^"lq_tmp_x1889" | k_1888}
              -&gt; {VV#1890 : v^"lq_tmp_x1892" | k_1891})
-&gt; lq_tmp_x1886:{VV#1887 : v^"lq_tmp_x1889" | k_1888}
-&gt; {VV#1890 : v^"lq_tmp_x1892" | k_1891}</span><span class='hs-varop'>$</span></a>
<span class=hs-linenum>499: </span>                  <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1677:k
-&gt; lq_tmp_x1678:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1677 keys m}
-&gt; v</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1879 : (AssocativeMap.Map {VV : k | VV &lt; k#a1mo} v) | lq_tmp_x1879 == l#a1mq}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>500: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1789:{lq_tmp_x1794 : GHC.Types.Bool^"lq_tmp_x1793" "lq_tmp_x164" | k_1792[VV#1791:=lq_tmp_x1794]}
-&gt; lq_tmp_x1790:{VV#1795 : v^"lq_tmp_x1797" "lq_tmp_x166" | k_1796}
-&gt; {VV#1795 : v^"lq_tmp_x1797" "lq_tmp_x167" | k_1796}</span><span class='hs-varid'>assert</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall k v.
lq_tmp_x688:k
-&gt; lq_tmp_x689:(AssocativeMap.Map {VV : k | VV /= lq_tmp_x688} v)
-&gt; {v : GHC.Types.Bool | not (Set_mem lq_tmp_x688 keys lq_tmp_x689)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1785 : (AssocativeMap.Map {VV : k | VV &lt; k#a1mo} v) | lq_tmp_x1785 == l#a1mq}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1821:(lq_tmp_x1820:{VV#1823 : v^"lq_tmp_x1825" | k_1824}
              -&gt; {VV#1826 : v^"lq_tmp_x1828" | k_1827})
-&gt; lq_tmp_x1822:{VV#1823 : v^"lq_tmp_x1825" | k_1824}
-&gt; {VV#1826 : v^"lq_tmp_x1828" | k_1827}</span><span class='hs-varop'>$</span></a>
<span class=hs-linenum>501: </span>                  <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x1677:k
-&gt; lq_tmp_x1678:{m : (AssocativeMap.Map k v) | Set_mem lq_tmp_x1677 keys m}
-&gt; v</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mn}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1815 : (AssocativeMap.Map {VV : k | k#a1mo &lt; VV} v) | lq_tmp_x1815 == r#a1mr}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>502: </span><span class='hs-definition'>get</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1920:{lq_tmp_x1918 : [GHC.Types.Char] | false}
-&gt; {VV#1921 : v^"lq_tmp_x1923" | k_1922}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1927 : [GHC.Types.Char^"lq_tmp_x10"]&lt;\lq_tmp_x1925 VV -&gt; True&gt;^"lq_tmp_x12" | len lq_tmp_x1927 &gt;= 0 &amp;&amp; lq_tmp_x1927 == lq_anf__d1vQ}</span><span class='hs-str'>"Lookup failed? Impossible."</span></a>
</pre>
<p>By calling <code>lemma_notMem</code> we create a dummy <code>Bool</code> that carries the desired refinement that tells LiquidHaskell that <code>not (HasKey k' r)</code> (resp. <code>not (HasKey k' l)</code>). We force the calls to <code>get k' l</code> (resp. <code>get k' r</code>) to be typechecked using the materialized refinement by wrapping the calls within a function <code>assert</code></p>
<pre><span class=hs-linenum>511: </span><a class=annot href="#"><span class=annottext>forall t t.
lq_tmp_x683:t^"lq_tmp_x164"
-&gt; lq_tmp_x684:t^"lq_tmp_x166" -&gt; t^"lq_tmp_x167"</span><span class='hs-definition'>assert</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>t^"lq_tmp_x166"</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : t^"lq_tmp_x166" | VV == x#a1ms}</span><span class='hs-varid'>x</span></a>
</pre>
<p> This technique of materializing auxiliary facts via <em>ghost values</em> is a well known idea in the program verification literature. Usually, one has to take care to ensure that ghost computations do not interfere with the regular computations. If we had to actually <em>execute</em> <code>lemma_notMem</code> it would totally wreck the efficient logarithmic lookup times  as we'd traverse the entire tree all the time </p>
<p> comes to our rescue: as the ghost value is (trivially) not needed, it is never computed. In fact, it is straightforward to entirely <em>erase</em> the call in the compiled code, which lets us freely <code>assert</code> such <code>lemma</code>s to carry out proofs, without paying any runtime penalty. In an eager language we would have to do a bit of work to specifically mark the computation as a ghost or <a href="proof-irrelevance">irrelevant</a> but in the lazy setting we get this for free.</p>
<p> Capisce? Fix the definition of <code>mem</code> so that it verifiably implements the given signature:</p>
<pre><span class=hs-linenum>537: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| Prop v &lt;=&gt; HasKey k m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>538: </span><span class=hs-error><a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x537:k
-&gt; lq_tmp_x538:(AssocativeMap.Map k v)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem lq_tmp_x537 keys lq_tmp_x538}</span><span class='hs-definition'>mem</span></a></span> <a class=annot href="#"><span class=annottext>k</span><span class='hs-varid'>k'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>539: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mt}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x585:{VV#587 : k^"lq_tmp_x589" | k_588[lq_tmp_x584:=fix##36#dEq_a1pH]}
-&gt; lq_tmp_x586:{VV#587 : k^"lq_tmp_x589" | k_588[lq_tmp_x584:=fix##36#dEq_a1pH]}
-&gt; {lq_tmp_x580 : GHC.Types.Bool | Prop lq_tmp_x580 &lt;=&gt; lq_tmp_x585 == lq_tmp_x586}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mu}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x676 : GHC.Types.Bool | Prop lq_tmp_x676 &amp;&amp; lq_tmp_x676 == GHC.Types.True#6u}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>540: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mt}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x612:{VV#614 : k^"lq_tmp_x616" | k_615[lq_tmp_x611:=fix##36#dOrd_a1pE]}
-&gt; lq_tmp_x613:{VV#614 : k^"lq_tmp_x616" | k_615[lq_tmp_x611:=fix##36#dOrd_a1pE]}
-&gt; {lq_tmp_x607 : GHC.Types.Bool | Prop lq_tmp_x607 &lt;=&gt; lq_tmp_x612 &lt; lq_tmp_x613}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : k | VV == k#a1mu}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x537:k
-&gt; lq_tmp_x538:(AssocativeMap.Map k v)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem lq_tmp_x537 keys lq_tmp_x538}</span><span class='hs-varid'>mem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mt}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x669 : (AssocativeMap.Map {VV : k | VV &lt; k#a1mu} v) | lq_tmp_x669 == l#a1mv}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>541: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall k v.
(GHC.Classes.Ord k) =&gt;
lq_tmp_x537:k
-&gt; lq_tmp_x538:(AssocativeMap.Map k v)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem lq_tmp_x537 keys lq_tmp_x538}</span><span class='hs-varid'>mem</span></a> <a class=annot href="#"><span class=annottext>{VV : k | VV == k'#a1mt}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x646 : (AssocativeMap.Map {VV : k | k#a1mu &lt; VV} v) | lq_tmp_x646 == r#a1mw}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>542: </span><span class='hs-definition'>mem</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x682 : GHC.Types.Bool | not (Prop lq_tmp_x682) &amp;&amp; lq_tmp_x682 == GHC.Types.False#68}</span><span class='hs-conid'>False</span></a>
</pre>
<p> To make sure you really understand this business of ghosts values and proofs, complete the implementation of the following function which returns a <code>fresh</code> integer that is <em>distinct</em> from all the values in its input list:</p>
<pre><span class=hs-linenum>550: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| not (Elem v xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>551: </span><a class=annot href="#"><span class=annottext>lq_tmp_x514:[GHC.Types.Int]
-&gt; {v : GHC.Types.Int | not (Set_mem v elems lq_tmp_x514)}</span><span class='hs-definition'>fresh</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. a^"lq_tmp_x21"</span><span class='hs-varid'>undefined</span></a>
</pre>
<p>To refresh your memory, here are the definitions for <code>Elem</code> we <a href="#listelems">saw earlier</a></p>
<pre><span class=hs-linenum>558: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Elem</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_mem</span> <span class='hs-conid'>X</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span> <span class='hs-conid'>Ys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>559: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>elems</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>560: </span><a class=annot href="#"><span class=annottext>forall a.
(GHC.Classes.Ord a) =&gt;
lq_tmp_x437:[a]
-&gt; {VV : (Data.Set.Base.Set a) | VV == elems lq_tmp_x437}</span><span class='hs-definition'>elems</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a.
{lq_tmp_x452 : (Data.Set.Base.Set a) | Set_emp lq_tmp_x452}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>561: </span><span class='hs-definition'>elems</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x478:{VV#479 : a^"lq_tmp_x481" | k_480}
-&gt; {lq_tmp_x476 : (Data.Set.Base.Set {VV#479 : a^"lq_tmp_x481" | k_480}) | lq_tmp_x476 == Set_sng lq_tmp_x478}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x#a1mx}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x506:(Data.Set.Base.Set {VV#508 : a^"lq_tmp_x510" | k_509[lq_tmp_x505:=fix##36#dOrd_a1pt]})
-&gt; lq_tmp_x507:(Data.Set.Base.Set {VV#508 : a^"lq_tmp_x510" | k_509[lq_tmp_x505:=fix##36#dOrd_a1pt]})
-&gt; {lq_tmp_x501 : (Data.Set.Base.Set {VV#508 : a^"lq_tmp_x510" | k_509[lq_tmp_x505:=fix##36#dOrd_a1pt]}) | lq_tmp_x501 == Set_cup lq_tmp_x506 lq_tmp_x507}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a.
(GHC.Classes.Ord a) =&gt;
lq_tmp_x437:[a]
-&gt; {VV : (Data.Set.Base.Set a) | VV == elems lq_tmp_x437}</span><span class='hs-varid'>elems</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x496 : [a] | len lq_tmp_x496 &gt;= 0 &amp;&amp; lq_tmp_x496 == xs#a1my}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
<h2 id="recap">Recap</h2>
<p>In this chapter we saw how to combine several of the techniques from previous chapters in a case study. We learnt how to:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Define</strong> an API for associative maps that used refinements to track the <em>set</em> of <code>keys</code> stored in a map, in order to prevent lookup failures, the <code>NullPointerDereference</code> errors of the functional world,</p></li>
<li><p><strong>Use</strong> the API to implement a small interpreter that is guaranteed to never fail with <code>UnboundVariable</code> errors, as long as the input expressions were closed,</p></li>
<li><p><strong>Implement</strong> the API using Binary Search Trees; in particular, using <em>ghost lemmas</em> to <code>assert</code> facts that LiquidHaskell is otherwise unable to deduce automatically.</p></li>
</ol>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

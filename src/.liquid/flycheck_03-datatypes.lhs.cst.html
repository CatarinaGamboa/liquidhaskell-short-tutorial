<h1 id="refineddatatypes">Refined Datatypes</h1>

<p>So far, we have seen how to refine the types of <em>functions</em>, to specify, for example, preconditions on the inputs, or postconditions on the outputs. Very often, we wish to define <em>datatypes</em> that satisfy certain invariants. In these cases, it is handy to be able to directly refine the the <code>data</code> definition, so that it is impossible to create illegal inhabitants.</p>
<h2 id="sparsedata">Sparse Vectors Revisited</h2>
<p>As our first example of a refined datatype, lets revisit the sparse vector representation that we <a href="#sparsetype">saw earlier</a>. The <code>SparseN</code> type alias we used got the job done, but is not pleasant to work with because we have no way of determining the <em>dimension</em> of the sparse vector. Instead, lets create a new datatype to represent such vectors:</p>
<pre><span class=hs-linenum>75: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spDim</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>76: </span>                   <span class='hs-layout'>,</span> <span class='hs-varid'>spElems</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span> 
</pre>
<p>Thus, a sparse vector is a pair of a dimension and a list of index-value tuples. Implicitly, all indices <em>other</em> than those in the list have the value <code>0</code> or the equivalent value type <code>a</code>.</p>
<p> <code>Sparse</code> vectors satisfy two crucial properties. First, the dimension stored in <code>spDim</code> is non-negative. Second, every index in <code>spElems</code> must be valid, i.e. between <code>0</code> and the dimension. Unfortunately, Haskell's type system does not make it easy to ensure that <em>illegal vectors are not representable</em>. </p>
<p> LiquidHaskell lets us enforce these invariants with a refined data definition:</p>
<pre><span class=hs-linenum>100: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spDim</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> 
<span class=hs-linenum>101: </span>                       <span class='hs-layout'>,</span> <span class='hs-varid'>spElems</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Btwn</span> <span class='hs-num'>0</span> <span class='hs-varid'>spDim</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Where, as before, the we use the aliases:</p>
<pre><span class=hs-linenum>107: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Nat</span>        <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span>            <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>108: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Btwn</span> <span class='hs-conid'>Lo</span> <span class='hs-conid'>Hi</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lo</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>Hi</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p> The refined data definition is internally converted into refined types for the data constructor <code>SP</code>:</p>
<pre><span class=hs-linenum>116: </span><span class='hs-comment'>-- Generated Internal representation</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>118: </span>  <span class='hs-conid'>SP</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>spDim</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>spElems</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Btwn</span> <span class='hs-num'>0</span> <span class='hs-varid'>spDim</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> 
</pre>
<p>{#autosmart} In other words, by using refined input types for <code>SP</code> we have automatically converted it into a <em>smart</em> constructor that ensures that <em>every</em> instance of a <code>Sparse</code> is legal. Consequently, LiquidHaskell verifies:</p>
<pre><span class=hs-linenum>128: </span><span class='hs-definition'>okSP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Sparse</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>129: </span><span class='hs-definition'>okSP</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>5</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-str'>"cat"</span><span class='hs-layout'>)</span>
<span class=hs-linenum>130: </span>            <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-str'>"dog"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span> 
</pre>
<p>but rejects, due to the invalid index:</p>
<pre><span class=hs-linenum>136: </span><span class='hs-definition'>badSP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Sparse</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>137: </span><span class='hs-definition'>badSP</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>5</span> <span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-layout'>(</span></span><span class=hs-error><span class='hs-num'>0</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-str'>"cat"</span></span><span class=hs-error><span class='hs-layout'>)</span></span><span class=hs-error>
</span><span class=hs-linenum>138: </span>             <span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-layout'>(</span></span><span class=hs-error><span class='hs-num'>6</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-str'>"dog"</span></span><span class=hs-error><span class='hs-layout'>)</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>]</span></span>
</pre>
<p> It is convenient to write an alias for sparse vectors of a given size <code>N</code>. We can use the field name <code>spDim</code> as a <em>measure</em>, like <code>vlen</code>. That is, we can use <code>spDim</code> inside refinements:</p>
<pre><span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>SparseN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>spDim</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-conid'>N</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span> 
</pre>
<p> Lets write a function to compute a sparse product</p>
<pre><span class=hs-linenum>154: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>dotProd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Vector</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>vlen</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>155: </span><span class='hs-definition'>dotProd</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>SP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>156: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>157: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>y'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>!</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>y'</span> 
<span class=hs-linenum>158: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>sum</span> <span class='hs-conid'>[]</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span>
</pre>
<p>LiquidHaskell verifies the above by using the specification to conclude that for each tuple <code>(i, v)</code> in the list <code>y</code>, the value of <code>i</code> is within the bounds of the vector <code>x</code>, thereby proving <code>x ! i</code> safe.</p>
<p> We can port the <code>fold</code>-based product to our new representation:</p>
<pre><span class=hs-linenum>170: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>dotProd'</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Vector</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>vlen</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>171: </span><span class='hs-definition'>dotProd'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>SP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>body</span> <span class='hs-num'>0</span> <span class='hs-varid'>y</span>   
<span class=hs-linenum>172: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>173: </span>    <span class='hs-varid'>body</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>!</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>  <span class='hs-varop'>*</span> <span class='hs-varid'>v</span>
</pre>
<p>As before, LiquidHaskell checks the above by <a href="#sparsetype">automatically instantiating refinements</a> for the type parameters of <code>foldl'</code>, saving us a fair bit of typing and enabling the use of the elegant polymorphic, higher-order combinators we know and love.</p>
<p> <strong>[Sanitization]</strong> Invariants are all well and good for data computed <em>inside</em> our programs. The only way to ensure the legality of data coming from <em>outside</em>, i.e. from the &quot;real world&quot;, is to writing a sanitizer that will check the appropriate invariants before constructing a <code>Sparse</code> vector. Write the specification and implementation of a sanitizer <code>fromList</code>, so that the following typechecks:</p>
<pre><span class=hs-linenum>192: </span><span class='hs-definition'>fromList</span>          <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>193: </span><span class='hs-definition'>fromList</span> <span class='hs-varid'>dim</span> <span class='hs-varid'>elts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>   
<span class=hs-linenum>194: </span>
<span class=hs-linenum>195: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test1</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>String</span> <span class='hs-num'>3</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>196: </span><span class='hs-definition'>test1</span>             <span class='hs-keyglyph'>=</span> <span class=hs-error><span class='hs-varid'>fromJust</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varop'>$</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>fromList</span></span><span class=hs-error>  </span><span class=hs-error><span class='hs-num'>3</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error><span class='hs-layout'>(</span></span><span class=hs-error><span class='hs-num'>0</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-str'>"cat"</span></span><span class=hs-error><span class='hs-layout'>)</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-layout'>(</span></span><span class=hs-error><span class='hs-num'>2</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-str'>"mouse"</span></span><span class=hs-error><span class='hs-layout'>)</span></span><span class=hs-error><span class='hs-keyglyph'>]</span></span>
</pre>
<p> <strong>[Addition]</strong> Write the specification and implementation of a function <code>plus</code> that performs the addition of two <code>Sparse</code> vectors of the <em>same</em> dimension, yielding an output of that dimension. When you are done, the following code should typecheck:</p>
<pre><span class=hs-linenum>205: </span><span class='hs-definition'>plus</span>     <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>206: </span><span class='hs-definition'>plus</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span> 
<span class=hs-linenum>207: </span>
<span class=hs-linenum>208: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SparseN</span> <span class='hs-conid'>Int</span> <span class='hs-num'>3</span> <span class='hs-keyword'>@-}</span>   
<span class=hs-linenum>209: </span><span class='hs-definition'>test2</span>    <span class='hs-keyglyph'>=</span> <span class=hs-error><span class='hs-varid'>plus</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>vec1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>vec2</span></span> 
<span class=hs-linenum>210: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>211: </span>    <span class='hs-varid'>vec1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>3</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>12</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-num'>9</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>212: </span>    <span class='hs-varid'>vec2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SP</span> <span class='hs-num'>3</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>8</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>  <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>100</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
</pre>
<h2 id="ordered-lists">Ordered Lists</h2>
<p>As a second example of refined data types, lets consider a different problem: representing <em>ordered</em> sequences. Here's a type for sequences that mimics the classical list:</p>
<pre><span class=hs-linenum>223: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span>
<span class=hs-linenum>224: </span>               <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conop'>:&lt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>   
<span class=hs-linenum>225: </span>
<span class=hs-linenum>226: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span> <span class='hs-conop'>:&lt;</span>
</pre>
<p>The Haskell type above does not state that the elements be in order of course, but we can specify that requirement by refining <em>every</em> element in <code>tl</code> to be <em>greater than</em> <code>hd</code>:</p>
<pre><span class=hs-linenum>235: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span>
<span class=hs-linenum>236: </span>                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conop'>:&lt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hd</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>237: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p> Once again, the refined data definition is internally converted into a &quot;smart&quot; refined data constructor</p>
<pre><span class=hs-linenum>245: </span><span class='hs-comment'>-- Generated Internal representation</span>
<span class=hs-linenum>246: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>247: </span>  <span class='hs-conid'>Emp</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>248: </span>  <span class='hs-layout'>(</span><span class='hs-conop'>:&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>hd</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tl</span><span class='hs-conop'>:</span><span class='hs-conid'>IncList</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hd</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
</pre>
<p>which ensures that we can only create legal ordered lists.</p>
<pre><span class=hs-linenum>254: </span><span class='hs-definition'>okList</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-conop'>:&lt;</span> <span class='hs-num'>2</span> <span class='hs-conop'>:&lt;</span> <span class='hs-num'>3</span> <span class='hs-conop'>:&lt;</span> <span class='hs-conid'>Emp</span>      <span class='hs-comment'>-- accepted by LH</span>
<span class=hs-linenum>255: </span>
<span class=hs-linenum>256: </span><span class='hs-definition'>badList</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-conop'>:&lt;</span> <span class=hs-error><span class='hs-num'>1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-conop'>:&lt;</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>3</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-conop'>:&lt;</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-conid'>Emp</span></span>      <span class='hs-comment'>-- rejected by LH</span>
</pre>
<p>Its all very well to <em>specify</em> ordered lists. Next, lets see how its equally easy to <em>establish</em> these invariants by implementing several textbook sorting routines.</p>
<p> First, lets implement insertion sort, which converts an ordinary list <code>[a]</code> into an ordered list <code>IncList a</code>.</p>
<pre><span class=hs-linenum>270: </span><span class='hs-definition'>insertSort</span>        <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>271: </span><span class='hs-definition'>insertSort</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span> 
<span class=hs-linenum>272: </span><span class='hs-definition'>insertSort</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insert</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>insertSort</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> 
</pre>
<p>The hard work is done by <code>insert</code> which places an element into the correct position of a sorted list. LiquidHaskell infers that if you give <code>insert</code> an element and a sorted list, it returns a sorted list.</p>
<pre><span class=hs-linenum>281: </span><span class='hs-definition'>insert</span>             <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>282: </span><span class='hs-definition'>insert</span> <span class='hs-varid'>y</span> <span class='hs-conid'>Emp</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-conop'>:&lt;</span> <span class='hs-conid'>Emp</span>
<span class=hs-linenum>283: </span><span class='hs-definition'>insert</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>284: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>x</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>285: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>insert</span> <span class='hs-varid'>y</span> <span class='hs-varid'>xs</span>
</pre>
<p>Complete the implementation of the function below to use <code>foldr</code> to eliminate the explicit recursion in <code>insertSort</code>.</p>
<pre><span class=hs-linenum>292: </span><span class='hs-definition'>insertSort'</span>     <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>293: </span><span class='hs-definition'>insertSort'</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-varid'>xs</span>
<span class=hs-linenum>294: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>295: </span>     <span class='hs-varid'>f</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>    <span class='hs-comment'>-- Fill this in</span>
<span class=hs-linenum>296: </span>     <span class='hs-varid'>b</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>    <span class='hs-comment'>-- Fill this in</span>
</pre>
<p> Similarly, it is easy to write merge sort, by implementing the three steps. First, we write a function that <em>splits</em> the input into two equal sized halves:</p>
<pre><span class=hs-linenum>304: </span><span class='hs-definition'>split</span>          <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class=hs-linenum>305: </span><span class='hs-definition'>split</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>zs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>306: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>307: </span>    <span class='hs-layout'>(</span><span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>zs</span>
<span class=hs-linenum>308: </span><span class='hs-definition'>split</span> <span class='hs-varid'>xs</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
</pre>
<p>Second, we need a function that <em>combines</em> two ordered lists</p>
<pre><span class=hs-linenum>315: </span><span class='hs-definition'>merge</span>         <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>316: </span><span class='hs-definition'>merge</span> <span class='hs-varid'>xs</span>  <span class='hs-conid'>Emp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
<span class=hs-linenum>317: </span><span class='hs-definition'>merge</span> <span class='hs-conid'>Emp</span> <span class='hs-varid'>ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<span class=hs-linenum>318: </span><span class='hs-definition'>merge</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>319: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>y</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>merge</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>merge</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span>
</pre>
<p>Finally, we compose the above steps to divide (i.e. <code>split</code>) and conquer (<code>sort</code> and <code>merge</code>) the input list:</p>
<pre><span class=hs-linenum>328: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mergeSort</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>329: </span><span class='hs-definition'>mergeSort</span> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span>  
<span class=hs-linenum>330: </span><span class='hs-definition'>mergeSort</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-conid'>Emp</span>
<span class=hs-linenum>331: </span><span class='hs-definition'>mergeSort</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>merge</span> <span class='hs-layout'>(</span><span class='hs-varid'>mergeSort</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mergeSort</span> <span class='hs-varid'>zs</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>332: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>333: </span>    <span class='hs-layout'>(</span><span class='hs-varid'>ys</span><span class='hs-layout'>,</span> <span class='hs-varid'>zs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>xs</span>
</pre>
<p>Why is the following implementation of <code>quickSort</code> rejected by LiquidHaskell? Modify it so it is accepted.</p>
<pre><span class=hs-linenum>340: </span><span class='hs-definition'>quickSort</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>341: </span><span class='hs-definition'>quickSort</span> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span> 
<span class=hs-linenum>342: </span><span class='hs-definition'>quickSort</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>append</span> <span class='hs-varid'>lessers</span> <span class='hs-varid'>greaters</span> 
<span class=hs-linenum>343: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>344: </span>    <span class='hs-varid'>lessers</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quickSort</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>]</span>
<span class=hs-linenum>345: </span>    <span class='hs-varid'>greaters</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quickSort</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>z</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>z</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>346: </span>
<span class=hs-linenum>347: </span><span class='hs-definition'>append</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>348: </span><span class='hs-definition'>append</span> <span class='hs-conid'>Emp</span>       <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<span class=hs-linenum>349: </span><span class='hs-definition'>append</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class=hs-error><span class='hs-varid'>append</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>xs</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>ys</span></span> 
</pre>
<h2 id="binarysearchtree">Ordered Trees</h2>
<p>As a last example of refined data types, let us consider binary search ordered trees, defined thus:</p>
<pre><span class=hs-linenum>359: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span>
<span class=hs-linenum>360: </span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <span class='hs-varid'>root</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>361: </span>                  <span class='hs-layout'>,</span> <span class='hs-varid'>left</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>362: </span>                  <span class='hs-layout'>,</span> <span class='hs-varid'>right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
</pre>
<p> enjoy the [property][bst-wiki] that each <code>root</code> lies (strictly) between the elements belonging in the <code>left</code> and <code>right</code> subtrees hanging off the the root. The ordering invariant makes it easy to check whether a certain value occurs in the tree. If the tree is empty i.e. a Leaf, then the value does not occur in the tree. If the given value is at the root then the value does occur in the tree. If it is less than (respectively greater than) the root, we recursively check whether the value occurs in the left (respectively right) subtree.</p>

<p>Figure  shows a binary search tree whose nodes are labeled with a subset of values from <code>1</code> to <code>9</code>. We might represent such a tree with the Haskell value:</p>
<pre><span class=hs-linenum>391: </span><span class='hs-definition'>okBST</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>392: </span><span class='hs-definition'>okBST</span> <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>Node</span> <span class='hs-num'>6</span> 
<span class=hs-linenum>393: </span>             <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>2</span>
<span class=hs-linenum>394: </span>                 <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>1</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
<span class=hs-linenum>395: </span>                 <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>4</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>396: </span>             <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>9</span>
<span class=hs-linenum>397: </span>                 <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>7</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
<span class=hs-linenum>398: </span>                 <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
</pre>
<p> The Haskell type says nothing about the ordering invariant, and hence, cannot prevent us from creating illegal <code>BST</code> values that violate the invariant. We can remedy this with a refined data definition that captures the invariant:</p>
<pre><span class=hs-linenum>407: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span>
<span class=hs-linenum>408: </span>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <span class='hs-varid'>root</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>409: </span>                      <span class='hs-layout'>,</span> <span class='hs-varid'>left</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>root</span><span class='hs-layout'>}</span>
<span class=hs-linenum>410: </span>                      <span class='hs-layout'>,</span> <span class='hs-varid'>right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>root</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>411: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p> As before, the above data definition creates a refined &quot;smart&quot; constructor for <code>BST</code></p>
<pre><span class=hs-linenum>419: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>420: </span>  <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>421: </span>  <span class='hs-conid'>Node</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>r</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>r</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
</pre>
<p>which <em>prevents</em> us from creating illegal trees</p>
<pre><span class=hs-linenum>427: </span><span class='hs-definition'>badBST</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>428: </span><span class='hs-definition'>badBST</span> <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>Node</span> <span class='hs-num'>6</span> 
<span class=hs-linenum>429: </span>             <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>4</span>
<span class=hs-linenum>430: </span>                 <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>1</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
<span class=hs-linenum>431: </span>                 <span class='hs-layout'>(</span><span class=hs-error><span class='hs-conid'>Node</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>2</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-conid'>Leaf</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-conid'>Leaf</span></span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Out of order, rejected by LH </span>
<span class=hs-linenum>432: </span>             <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>9</span>
<span class=hs-linenum>433: </span>                 <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-num'>7</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
<span class=hs-linenum>434: </span>                 <span class='hs-conid'>Leaf</span><span class='hs-layout'>)</span>
</pre>
<p>Can a <code>BST Int</code> contain duplicates?</p>
<p> Lets write some functions to create and manipulate these trees. First, a function to check whether a value is in a <code>BST</code>:</p>
<pre><span class=hs-linenum>445: </span><span class='hs-definition'>mem</span>                 <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>446: </span><span class='hs-definition'>mem</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Leaf</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class=hs-linenum>447: </span><span class='hs-definition'>mem</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>448: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k</span> <span class='hs-varop'>==</span> <span class='hs-varid'>k'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>449: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k</span> <span class='hs-varop'>&lt;</span>  <span class='hs-varid'>k'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mem</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l</span>
<span class=hs-linenum>450: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mem</span> <span class='hs-varid'>k</span> <span class='hs-varid'>r</span> 
</pre>
<p> Next, another easy warm-up: a function to create a <code>BST</code> with a single given element:</p>
<pre><span class=hs-linenum>457: </span><span class='hs-definition'>one</span>   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>458: </span><span class='hs-definition'>one</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>x</span> <span class='hs-conid'>Leaf</span> <span class='hs-conid'>Leaf</span>
</pre>
<p> Next, lets write a function that adds an element to a <code>BST</code>. </p>
<pre><span class=hs-linenum>467: </span><span class='hs-definition'>add</span>                  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>468: </span><span class='hs-definition'>add</span> <span class='hs-varid'>k'</span> <span class='hs-conid'>Leaf</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>one</span> <span class='hs-varid'>k'</span>
<span class=hs-linenum>469: </span><span class='hs-definition'>add</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>470: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k'</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>k</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>add</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<span class=hs-linenum>471: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k</span>  <span class='hs-varop'>&lt;</span> <span class='hs-varid'>k'</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>add</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>472: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> 
</pre>
<p> Next, lets write a function to delete the <em>minimum</em> element from a <code>BST</code>. This function will return a <em>pair</em> of outputs -- the smallest element and the remainder of the tree. We can say that the output element is indeed the smallest, by saying that the remainder's elements exceed the element. To this end, lets define a helper type: </p>
<pre><span class=hs-linenum>486: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>MinPair</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>minElt</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>rest</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
</pre>
<p>We can specify that <code>minElt</code> is indeed smaller than all the elements in <code>rest</code> via the data type refinement:</p>
<pre><span class=hs-linenum>493: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>MinPair</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>minElt</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>rest</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>minElt</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Finally, we can write the code to compute <code>MinPair</code></p>
<pre><span class=hs-linenum>499: </span><span class='hs-definition'>delMin</span>                 <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MinPair</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>500: </span><span class='hs-definition'>delMin</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-conid'>Leaf</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MP</span> <span class='hs-varid'>k</span> <span class='hs-varid'>r</span>
<span class=hs-linenum>501: </span><span class='hs-definition'>delMin</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MP</span> <span class='hs-varid'>k'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l'</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>502: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>503: </span>    <span class='hs-conid'>MP</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>l'</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delMin</span> <span class='hs-varid'>l</span> 
<span class=hs-linenum>504: </span><span class='hs-definition'>delMin</span> <span class='hs-conid'>Leaf</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>die</span> <span class=hs-error><span class='hs-str'>"Don't say I didn't say I didn't warn ya!"</span></span>
</pre>
<p> <strong>[Deletion]</strong> Use <code>delMin</code> to complete the implementation of <code>del</code> which <em>deletes</em> a given element from a <code>BST</code>, if it is present.</p>
<pre><span class=hs-linenum>512: </span><span class='hs-definition'>del</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>513: </span><span class='hs-definition'>del</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>514: </span><span class='hs-definition'>del</span> <span class='hs-keyword'>_</span>  <span class='hs-varid'>t</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span>
</pre>
<p>The function <code>delMin</code> is only sensible for non-empty trees. <a href="#usingmeasures">Read ahead</a> to learn how to specify and verify that it is only called with such trees, and then apply that technique here to verify the call to <code>die</code> in <code>delMin</code>.</p>
<p>Complete the implementation of <code>toIncList</code> to obtain a <code>BST</code> based sorting routine <code>bstSort</code>.</p>
<pre><span class=hs-linenum>526: </span><span class='hs-definition'>bstSort</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>527: </span><span class='hs-definition'>bstSort</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toIncList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>toBST</span>
<span class=hs-linenum>528: </span>
<span class=hs-linenum>529: </span><span class='hs-definition'>toBST</span>     <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>530: </span><span class='hs-definition'>toBST</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add</span> <span class='hs-conid'>Leaf</span>  
<span class=hs-linenum>531: </span>
<span class=hs-linenum>532: </span><span class='hs-definition'>toIncList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BST</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>533: </span><span class='hs-definition'>toIncList</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
</pre>
<p>This exercise will be a lot easier after you finish the <code>quickSort</code> exercise. Note that the signature for <code>toIncList</code> does not use <code>Ord</code> and so you cannot use a sorting procedure to implement it.</p>
<h2 id="recap">Recap</h2>
<p>In this chapter we saw how LiquidHaskell lets you refine data type definitions to capture sophisticated invariants. These definitions are internally represented by refining the types of the data constructors, automatically making them &quot;smart&quot; in that they preclude the creation of illegal values that violate the invariants. We will see much more of this handy technique in future chapters.</p>
<p>One recurring theme in this chapter was that we had to create new versions of standard datatypes, just in order to specify certain invariants. For example, we had to write a special list type, with its own <em>copies</em> of nil and cons. Similarly, to implement <code>delMin</code> we had to create our own pair type.</p>
<p> of types is quite tedious. There should be a way to just slap the desired invariants on to <em>existing</em> types, thereby facilitating their reuse. In a few chapters, we will see how to achieve this reuse by <em>abstracting refinements</em> from the definitions of datatypes or functions in the same way we abstract the element type <code>a</code> from containers like <code>[a]</code> or <code>BST a</code>.</p>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

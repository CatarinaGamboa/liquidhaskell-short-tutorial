16:1-16:4::AssocativeMap.die :: "forall a. {v : [GHC.Types.Char] | false} -> a"
16:5-16:6::x :: "{v : [GHC.Types.Char] | false}"
16:11-16:16::_ :: "[GHC.Types.Char] -> a"
16:17-16:18::x :: "{v : [GHC.Types.Char] | false}"
20:23-20:26::AssocativeMap.key :: "forall a b. (AssocativeMap.Map a b) -> a"
21:23-21:28::AssocativeMap.value :: "forall a b. (AssocativeMap.Map a b) -> b"
22:23-22:27::AssocativeMap.left :: "forall a b. (AssocativeMap.Map a b) -> (AssocativeMap.Map a b)"
23:23-23:28::AssocativeMap.right :: "forall a b. (AssocativeMap.Map a b) -> (AssocativeMap.Map a b)"
182:1-182:4::AssocativeMap.val :: "x1:AssocativeMap.Expr -> {VV : GHC.Types.Bool | Prop VV <=> val x1}"
182:20-182:24::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
183:20-183:25::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
184:20-184:25::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
185:20-185:25::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
200:1-200:5::AssocativeMap.plus :: "{v : AssocativeMap.Expr | val v}\n-> {v : AssocativeMap.Expr | val v}\n-> {v : AssocativeMap.Expr | val v}"
200:28-200:33::_ :: "GHC.Types.Int\n-> {v : AssocativeMap.Expr | val v <=> true && free v == Set_empty 0}"
200:35-200:36::i :: "{v : GHC.Types.Int | v == i}"
200:36-200:37::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
200:37-200:38::j :: "{v : GHC.Types.Int | v == j}"
201:28-201:31::_ :: "{v : [GHC.Types.Char] | false} -> {v : AssocativeMap.Expr | false}"
201:32-201:50::lq_anf__d1vj :: "{v : [GHC.Types.Char] | len v >= 0}"
225:1-225:5::AssocativeMap.eval :: "x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})\n-> {v : AssocativeMap.Expr | Set_sub free v keys x1}\n-> {v : AssocativeMap.Expr | val v}"
225:8-225:9::i :: "AssocativeMap.Expr"
225:24-225:25::lq_anf__d1vR :: "{v : AssocativeMap.Expr | val v <=> true && v == i && free v == Set_empty 0}"
226:24-226:27::AssocativeMap.get :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
226:28-226:29::x :: "{v : [GHC.Types.Char] | v == x && len v >= 0}"
226:30-226:31::ds_d1uo :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
227:24-227:28::_ :: "{v : AssocativeMap.Expr | val v}\n-> {v : AssocativeMap.Expr | val v}\n-> {v : AssocativeMap.Expr | val v}"
227:31-227:35::eval :: "x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})\n-> {VV : AssocativeMap.Expr | Set_sub free VV keys x1}\n-> {VV : AssocativeMap.Expr | val VV}"
227:36-227:37::ds_d1uo :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
227:38-227:40::e1 :: "{v : AssocativeMap.Expr | v == e1}"
227:43-227:47::eval :: "x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})\n-> {VV : AssocativeMap.Expr | Set_sub free VV keys x1}\n-> {VV : AssocativeMap.Expr | val VV}"
227:48-227:49::ds_d1uo :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
227:50-227:52::e2 :: "{v : AssocativeMap.Expr | v == e2}"
228:24-228:28::eval :: "x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})\n-> {VV : AssocativeMap.Expr | Set_sub free VV keys x1}\n-> {VV : AssocativeMap.Expr | val VV}"
228:29-228:31::g' :: "{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v && v /= i}) | v == g'}"
228:32-228:34::e2 :: "{v : AssocativeMap.Expr | v == e2}"
230:5-230:7::g' :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v && v /= i})"
230:24-230:27::AssocativeMap.set :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> b\n-> x4:(AssocativeMap.Map a b)\n-> {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}"
230:28-230:29::x :: "{v : [GHC.Types.Char] | v == x && len v >= 0}"
230:30-230:32::v1 :: "{v : AssocativeMap.Expr | val v && v == v1}"
230:33-230:34::ds_d1uo :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
231:5-231:7::v1 :: "{v : AssocativeMap.Expr | val v}"
231:24-231:28::eval :: "x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})\n-> {VV : AssocativeMap.Expr | Set_sub free VV keys x1}\n-> {VV : AssocativeMap.Expr | val VV}"
231:29-231:30::ds_d1uo :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
231:31-231:33::e1 :: "{v : AssocativeMap.Expr | v == e1}"
254:1-254:5::AssocativeMap.free :: "x1:AssocativeMap.Expr\n-> {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}"
254:22-254:27::Data.Set.Base.empty :: "forall a. {v : (Data.Set.Base.Set a) | Set_emp v}"
255:22-255:31::_ :: "x1:[GHC.Types.Char]\n-> {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_sng x1}"
255:32-255:33::x :: "{v : [GHC.Types.Char] | v == x && len v >= 0}"
256:23-256:27::AssocativeMap.free :: "x1:AssocativeMap.Expr\n-> {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}"
256:28-256:30::e1 :: "{v : AssocativeMap.Expr | v == e1}"
256:32-256:39::_ :: "x1:(Data.Set.Base.Set [GHC.Types.Char])\n-> x2:(Data.Set.Base.Set [GHC.Types.Char])\n-> {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_cup x1 v}"
256:41-256:45::AssocativeMap.free :: "x1:AssocativeMap.Expr\n-> {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}"
256:46-256:48::e2 :: "{v : AssocativeMap.Expr | v == e2}"
257:23-257:27::AssocativeMap.free :: "x1:AssocativeMap.Expr\n-> {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}"
257:28-257:30::e1 :: "{v : AssocativeMap.Expr | v == e1}"
257:32-257:39::_ :: "x1:(Data.Set.Base.Set [GHC.Types.Char])\n-> x2:(Data.Set.Base.Set [GHC.Types.Char])\n-> {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_cup x1 v}"
257:41-257:77::lq_anf__d1wg :: "(Data.Set.Base.Set [GHC.Types.Char])"
257:42-257:46::AssocativeMap.free :: "x1:AssocativeMap.Expr\n-> {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}"
257:47-257:49::e2 :: "{v : AssocativeMap.Expr | v == e2}"
257:51-257:63::_ :: "x1:(Data.Set.Base.Set [GHC.Types.Char])\n-> x2:(Data.Set.Base.Set [GHC.Types.Char])\n-> {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_dif x1 v}"
257:65-257:74::_ :: "x1:[GHC.Types.Char]\n-> {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_sng x1}"
257:75-257:76::x :: "{v : [GHC.Types.Char] | v == x && len v >= 0}"
285:1-285:8::AssocativeMap.topEval :: "{v : AssocativeMap.Expr | Set_emp free v}\n-> {v : AssocativeMap.Expr | val v}"
285:15-285:19::_ :: "x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})\n-> {v : AssocativeMap.Expr | Set_sub free v keys x1}\n-> {v : AssocativeMap.Expr | val v}"
285:20-285:23::lq_anf__d1vU :: "{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | false}) | Set_emp keys v}"
293:1-293:8::AssocativeMap.evalAny :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})\n-> AssocativeMap.Expr\n-> (Data.Maybe.Maybe {v : AssocativeMap.Expr | val v})"
293:9-293:10::g :: "(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})"
293:11-293:12::e :: "AssocativeMap.Expr"
294:5-294:7::_ :: "{v : GHC.Types.Bool | false}"
294:17-294:21::lq_anf__d1w4 :: "x1:{v : AssocativeMap.Expr | false}\n-> {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | isJust v <=> true && fromJust v == x1}"
294:22-294:23::_ :: "({v : AssocativeMap.Expr | false}\n -> {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | false})\n-> {v : AssocativeMap.Expr | false}\n-> {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | false}"
294:24-294:28::_ :: "x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})\n-> {v : AssocativeMap.Expr | Set_sub free v keys x1}\n-> {v : AssocativeMap.Expr | val v}"
294:29-294:30::g :: "{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v}) | v == g}"
294:31-294:32::e :: "{v : AssocativeMap.Expr | v == e}"
295:17-295:24::_ :: "{v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | isJust v <=> false}"
297:5-297:7::ok :: "forall a. {VV : a | false}"
297:17-297:26::_ :: "{VV : a | false}"
304:1-304:6::AssocativeMap.tests :: "[AssocativeMap.Expr]"
304:11-304:19::lq_anf__d1w1 :: "{v : [AssocativeMap.Expr] | null v <=> false && xListSelector v == v2 && len v >= 0}"
304:12-304:14::v1 :: "{v : AssocativeMap.Expr | val v && v == v1}"
304:16-304:18::v2 :: "{v : AssocativeMap.Expr | val v && v == v2}"
306:5-306:7::v1 :: "{v : AssocativeMap.Expr | val v}"
306:11-306:18::_ :: "{v : AssocativeMap.Expr | Set_emp free v}\n-> {v : AssocativeMap.Expr | val v}"
306:19-306:21::e1 :: "{v : AssocativeMap.Expr | val v <=> false && v == e1}"
307:5-307:7::v2 :: "{v : AssocativeMap.Expr | val v}"
307:11-307:18::_ :: "{v : AssocativeMap.Expr | Set_emp free v}\n-> {v : AssocativeMap.Expr | val v}"
307:19-307:21::e2 :: "{v : AssocativeMap.Expr | val v <=> false && v == e2 && free v == Set_cup free c10 Set_dif free e1 Set_sng x}"
308:5-308:7::e1 :: "{v : AssocativeMap.Expr | val v <=> false}"
308:12-308:15::_ :: "x1:[GHC.Types.Char]\n-> {v : AssocativeMap.Expr | val v <=> false && free v == Set_sng x1}"
308:16-308:17::x :: "{v : [GHC.Types.Char] | null v <=> false && v == x && len v >= 0}"
308:19-308:25::_ :: "x1:AssocativeMap.Expr\n-> x2:AssocativeMap.Expr\n-> {v : AssocativeMap.Expr | val v <=> false && free v == Set_cup free x1 free x2}"
308:26-308:28::c1 :: "{v : AssocativeMap.Expr | val v <=> true && v == c1 && free v == Set_empty 0}"
309:5-309:7::e2 :: "{v : AssocativeMap.Expr | val v <=> false && free v == Set_cup free c10 Set_dif free e1 Set_sng x}"
309:11-309:14::_ :: "x1:[GHC.Types.Char]\n-> x2:AssocativeMap.Expr\n-> x3:AssocativeMap.Expr\n-> {v : AssocativeMap.Expr | val v <=> false && free v == Set_cup free x2 Set_dif free v Set_sng x1}"
309:15-309:16::x :: "{v : [GHC.Types.Char] | null v <=> false && v == x && len v >= 0}"
309:17-309:20::c10 :: "{v : AssocativeMap.Expr | val v <=> true && v == c10 && free v == Set_empty 0}"
309:21-309:23::e1 :: "{v : AssocativeMap.Expr | val v <=> false && v == e1}"
310:5-310:6::x :: "{v : [GHC.Types.Char] | null v <=> false}"
310:11-310:14::_ :: "{v : [GHC.Types.Char] | null v <=> false}"
311:5-311:7::c1 :: "{v : AssocativeMap.Expr | val v <=> true && free v == Set_empty 0}"
311:11-311:16::_ :: "GHC.Types.Int\n-> {v : AssocativeMap.Expr | val v <=> true && free v == Set_empty 0}"
311:17-311:18::lq_anf__d1vW :: "{v : GHC.Types.Int | v == (1  :  int)}"
312:5-312:8::c10 :: "{v : AssocativeMap.Expr | val v <=> true && free v == Set_empty 0}"
312:11-312:16::_ :: "GHC.Types.Int\n-> {v : AssocativeMap.Expr | val v <=> true && free v == Set_empty 0}"
312:17-312:19::lq_anf__d1vV :: "{v : GHC.Types.Int | v == (10  :  int)}"
367:1-367:5::AssocativeMap.keys :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:(AssocativeMap.Map a b)\n-> {VV : (Data.Set.Base.Set a) | VV == keys x2}"
367:23-367:28::Data.Set.Base.empty :: "forall a. {v : (Data.Set.Base.Set a) | Set_emp v}"
368:23-368:28::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
368:30-368:39::_ :: "x1:a -> {v : (Data.Set.Base.Set a) | v == Set_sng x1}"
368:40-368:41::k :: "{VV : a | VV == k}"
368:44-368:49::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
368:51-368:55::AssocativeMap.keys :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:(AssocativeMap.Map a b)\n-> {VV : (Data.Set.Base.Set a) | VV == keys x2}"
368:56-368:57::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
368:60-368:64::AssocativeMap.keys :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:(AssocativeMap.Map a b)\n-> {VV : (Data.Set.Base.Set a) | VV == keys x2}"
368:65-368:66::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
379:1-379:4::AssocativeMap.emp :: "forall a b. {m : (AssocativeMap.Map a b) | Set_emp keys m}"
379:11-379:20::GHC.Err.undefined :: "forall a. a"
392:1-392:4::AssocativeMap.set :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> b\n-> x4:(AssocativeMap.Map a b)\n-> {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}"
392:5-392:7::k' :: "a"
392:8-392:10::v' :: "a"
393:5-393:7::k' :: "{VV : a | VV == k'}"
393:8-393:10::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
393:11-393:12::k :: "{VV : a | VV == k}"
393:17-393:21::_ :: "x1:a\n-> x2:b\n-> x3:(AssocativeMap.Map {VV : a | VV < x1} b)\n-> x4:(AssocativeMap.Map {VV : a | x1 < VV} b)\n-> {v : (AssocativeMap.Map a b) | keys v == Set_cup Set_sng x1 Set_cup keys x3 keys x4 && left v == x3 && right v == x4 && value v == x2 && key v == x1}"
393:22-393:23::k :: "{VV : a | VV == k}"
393:24-393:26::v' :: "{VV : a | VV == v'}"
393:27-393:28::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
393:29-393:30::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
394:5-394:7::k' :: "{VV : a | VV == k'}"
394:8-394:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
394:11-394:12::k :: "{VV : a | VV == k}"
394:17-394:20::AssocativeMap.set :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> b\n-> x4:(AssocativeMap.Map a b)\n-> {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}"
394:21-394:23::k' :: "{VV : a | VV == k'}"
394:24-394:25::v :: "{VV : a | VV == v}"
394:26-394:27::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
395:17-395:20::AssocativeMap.set :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> b\n-> x4:(AssocativeMap.Map a b)\n-> {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}"
395:21-395:23::k' :: "{VV : a | VV == k'}"
395:24-395:25::v :: "{VV : a | VV == v}"
395:26-395:27::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
396:17-396:21::_ :: "x1:a\n-> x2:b\n-> x3:(AssocativeMap.Map {VV : a | VV < x1} b)\n-> x4:(AssocativeMap.Map {VV : a | x1 < VV} b)\n-> {v : (AssocativeMap.Map a b) | keys v == Set_cup Set_sng x1 Set_cup keys x3 keys x4 && left v == x3 && right v == x4 && value v == x2 && key v == x1}"
396:22-396:24::k' :: "{VV : a | VV == k'}"
396:25-396:27::v' :: "{VV : a | VV == v'}"
396:28-396:31::lq_anf__d1va :: "{v : (AssocativeMap.Map {VV : a | false} b) | keys v == Set_empty 0}"
396:32-396:35::lq_anf__d1vb :: "{v : (AssocativeMap.Map {VV : a | false} b) | keys v == Set_empty 0}"
410:1-410:5::AssocativeMap.get' :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
410:6-410:8::k' :: "a"
410:9-410:10::m :: "{m : (AssocativeMap.Map a b) | Set_mem k' keys m}"
411:5-411:7::k' :: "{VV : a | VV == k'}"
411:8-411:10::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
411:11-411:12::k :: "{VV : a | VV == k}"
411:17-411:18::v :: "{VV : a | VV == v}"
412:5-412:7::k' :: "{VV : a | VV == k'}"
412:8-412:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
412:11-412:12::k :: "{VV : a | VV == k}"
412:17-412:21::AssocativeMap.get' :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
412:22-412:24::k' :: "{VV : a | VV == k'}"
412:25-412:26::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
413:17-413:21::AssocativeMap.get' :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
413:22-413:24::k' :: "{VV : a | VV == k'}"
413:25-413:26::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
414:17-414:20::_ :: "{v : [GHC.Types.Char] | false} -> a"
414:22-414:42::lq_anf__d1vE :: "{v : [GHC.Types.Char] | len v >= 0}"
477:1-477:13::AssocativeMap.lemma_notMem :: "forall a b.\nx1:a\n-> x2:(AssocativeMap.Map {VV : a | VV /= x1} b)\n-> {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}"
477:35-477:39::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
478:35-478:47::AssocativeMap.lemma_notMem :: "forall a b.\nx1:a\n-> x2:(AssocativeMap.Map {VV : a | VV /= x1} b)\n-> {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}"
478:48-478:51::ds_d1tQ :: "a"
478:52-478:53::l :: "{v : (AssocativeMap.Map a b) | v == l}"
478:54-478:56::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 && Prop v}"
478:57-478:69::AssocativeMap.lemma_notMem :: "forall a b.\nx1:a\n-> x2:(AssocativeMap.Map {VV : a | VV /= x1} b)\n-> {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}"
478:70-478:73::ds_d1tQ :: "a"
478:74-478:75::r :: "{v : (AssocativeMap.Map a b) | v == r}"
496:1-496:4::AssocativeMap.get :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
496:5-496:7::k' :: "a"
497:5-497:7::k' :: "{VV : a | VV == k'}"
497:8-497:10::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
497:11-497:12::k :: "{VV : a | VV == k}"
497:17-497:18::v :: "{VV : a | VV == v}"
498:5-498:7::k' :: "{VV : a | VV == k'}"
498:8-498:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
498:11-498:12::k :: "{VV : a | VV == k}"
498:17-498:23::_ :: "GHC.Types.Bool -> a -> a"
498:25-498:37::AssocativeMap.lemma_notMem :: "forall a b.\nx1:a\n-> x2:(AssocativeMap.Map {VV : a | VV /= x1} b)\n-> {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}"
498:38-498:40::k' :: "{VV : a | VV == k'}"
498:41-498:42::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
498:44-498:45::_ :: "(a -> a) -> a -> a"
499:19-499:22::AssocativeMap.get :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
499:23-499:25::k' :: "{VV : a | VV == k'}"
499:26-499:27::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
500:17-500:23::_ :: "GHC.Types.Bool -> a -> a"
500:25-500:37::AssocativeMap.lemma_notMem :: "forall a b.\nx1:a\n-> x2:(AssocativeMap.Map {VV : a | VV /= x1} b)\n-> {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}"
500:38-500:40::k' :: "{VV : a | VV == k'}"
500:41-500:42::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
500:44-500:45::_ :: "(a -> a) -> a -> a"
501:19-501:22::AssocativeMap.get :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a -> {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -> b"
501:23-501:25::k' :: "{VV : a | VV == k'}"
501:26-501:27::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
502:17-502:20::_ :: "{v : [GHC.Types.Char] | false} -> a"
502:21-502:49::lq_anf__d1vQ :: "{v : [GHC.Types.Char] | len v >= 0}"
511:1-511:7::AssocativeMap.assert :: "forall a b. a -> b -> b"
511:10-511:11::x :: "a"
511:14-511:15::x :: "{VV : a | VV == x}"
538:1-538:4::AssocativeMap.mem :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:(AssocativeMap.Map a b)\n-> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 keys x3}"
538:5-538:7::k' :: "a"
539:5-539:7::k' :: "{VV : a | VV == k'}"
539:8-539:10::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
539:11-539:12::k :: "{VV : a | VV == k}"
539:17-539:21::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
540:5-540:7::k' :: "{VV : a | VV == k'}"
540:8-540:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
540:11-540:12::k :: "{VV : a | VV == k}"
540:17-540:20::AssocativeMap.mem :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:(AssocativeMap.Map a b)\n-> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 keys x3}"
540:21-540:23::k' :: "{VV : a | VV == k'}"
540:24-540:25::l :: "{v : (AssocativeMap.Map {VV : a | VV < k} b) | v == l}"
541:17-541:20::AssocativeMap.mem :: "forall a b.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:(AssocativeMap.Map a b)\n-> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 keys x3}"
541:21-541:23::k' :: "{VV : a | VV == k'}"
541:24-541:25::r :: "{v : (AssocativeMap.Map {VV : a | k < VV} b) | v == r}"
542:17-542:22::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
551:1-551:6::AssocativeMap.fresh :: "x1:[GHC.Types.Int]\n-> {v : GHC.Types.Int | not (Set_mem v elems x1)}"
551:9-551:18::GHC.Err.undefined :: "forall a. a"
560:1-560:6::AssocativeMap.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
560:16-560:21::Data.Set.Base.empty :: "forall a. {v : (Data.Set.Base.Set a) | Set_emp v}"
561:17-561:26::_ :: "x1:a -> {v : (Data.Set.Base.Set a) | v == Set_sng x1}"
561:27-561:28::x :: "{VV : a | VV == x}"
561:30-561:37::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
561:39-561:44::AssocativeMap.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
561:45-561:47::xs :: "{v : [a] | v == xs && len v >= 0}"
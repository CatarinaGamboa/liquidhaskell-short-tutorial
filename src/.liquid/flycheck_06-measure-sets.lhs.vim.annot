17:1-17:5::Sets.main :: "(GHC.Types.IO ())"
17:8-17:14::_ :: "() -> (GHC.Types.IO ())"
17:15-17:17::GHC.Tuple.() :: "{v : () | v == GHC.Tuple.()}"
20:1-20:4::Sets.die :: "forall a. {v : [GHC.Types.Char] | false} -> a"
20:5-20:8::msg :: "{v : [GHC.Types.Char] | false}"
20:11-20:16::_ :: "[GHC.Types.Char] -> a"
20:17-20:20::msg :: "{v : [GHC.Types.Char] | false}"
29:1-29:3::Sets.q0 :: "forall a. a -> [a]"
29:8-29:10::GHC.Types.[] :: "forall a <p :: a a -> Prop>.\n{v : [a]<\\x7 VV -> p x7> | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0}"
125:1-125:25::Sets.prop_one_plus_one_eq_two :: "forall a.\n(GHC.Num.Num a, GHC.Classes.Eq a) =>\na -> {v : GHC.Types.Bool | Prop v}"
125:26-125:27::x :: "a"
125:33-125:34::x :: "{VV : a | VV == x}"
125:35-125:37::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
125:38-125:39::lq_anf__d20f :: "a"
125:40-125:41::_ :: "x1:a -> x2:a -> {VV : a | VV == x1 + x2}"
125:42-125:43::lq_anf__d20h :: "a"
125:45-125:54::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 => Prop v}"
125:56-125:57::x :: "{VV : a | VV == x}"
125:58-125:60::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
125:61-125:62::lq_anf__d20l :: "a"
132:1-132:8::Sets.implies :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 => Prop x2}"
132:22-132:26::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
133:22-133:26::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
134:22-134:27::_ :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
143:1-143:13::Sets.prop_x_y_200 :: "forall a b. a -> b -> {v : GHC.Types.Bool | Prop v}"
143:14-143:15::x :: "a"
143:16-143:17::y :: "a"
143:20-143:25::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
153:1-153:23::Sets.prop_intersection_comm :: "forall a.\n(GHC.Classes.Ord a) =>\n(Data.Set.Base.Set a)\n-> (Data.Set.Base.Set a) -> {v : GHC.Types.Bool | Prop v}"
153:24-153:25::x :: "(Data.Set.Base.Set a)"
153:26-153:27::y :: "(Data.Set.Base.Set a)"
154:6-154:7::x :: "{v : (Data.Set.Base.Set a) | v == x}"
154:8-154:22::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cap x1 v}"
154:23-154:24::y :: "{v : (Data.Set.Base.Set a) | v == y}"
154:26-154:28::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
154:30-154:31::y :: "{v : (Data.Set.Base.Set a) | v == y}"
154:32-154:46::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cap x1 v}"
154:47-154:48::x :: "{v : (Data.Set.Base.Set a) | v == x}"
162:1-162:17::Sets.prop_union_assoc :: "forall a.\n(GHC.Classes.Ord a) =>\n(Data.Set.Base.Set a)\n-> (Data.Set.Base.Set a) -> (Data.Set.Base.Set a) -> GHC.Types.Bool"
162:18-162:19::x :: "(Data.Set.Base.Set a)"
162:20-162:21::y :: "(Data.Set.Base.Set a)"
162:22-162:23::z :: "(Data.Set.Base.Set a)"
163:6-163:7::x :: "{v : (Data.Set.Base.Set a) | v == x}"
163:8-163:15::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
163:17-163:18::y :: "{v : (Data.Set.Base.Set a) | v == y}"
163:19-163:26::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
163:27-163:28::z :: "{v : (Data.Set.Base.Set a) | v == z}"
163:31-163:33::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
163:34-163:57::lq_anf__d206 :: "(Data.Set.Base.Set a)"
163:35-163:36::x :: "{v : (Data.Set.Base.Set a) | v == x}"
163:37-163:44::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
163:45-163:46::y :: "{v : (Data.Set.Base.Set a) | v == y}"
163:48-163:55::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
163:56-163:57::z :: "{v : (Data.Set.Base.Set a) | v == z}"
171:1-171:23::Sets.prop_intersection_dist :: "forall a.\n(GHC.Classes.Ord a) =>\n(Data.Set.Base.Set a)\n-> (Data.Set.Base.Set a)\n-> (Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v}"
171:24-171:25::x :: "(Data.Set.Base.Set a)"
171:26-171:27::y :: "(Data.Set.Base.Set a)"
171:28-171:29::z :: "(Data.Set.Base.Set a)"
172:6-172:7::x :: "{v : (Data.Set.Base.Set a) | v == x}"
172:8-172:22::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cap x1 v}"
172:24-172:25::y :: "{v : (Data.Set.Base.Set a) | v == y}"
172:26-172:33::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
172:34-172:35::z :: "{v : (Data.Set.Base.Set a) | v == z}"
172:37-172:39::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
172:40-172:89::lq_anf__d202 :: "(Data.Set.Base.Set a)"
172:41-172:42::x :: "{v : (Data.Set.Base.Set a) | v == x}"
172:43-172:57::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cap x1 v}"
172:58-172:59::y :: "{v : (Data.Set.Base.Set a) | v == y}"
172:61-172:68::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
172:70-172:71::x :: "{v : (Data.Set.Base.Set a) | v == x}"
172:72-172:86::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cap x1 v}"
172:87-172:88::z :: "{v : (Data.Set.Base.Set a) | v == z}"
181:1-181:17::Sets.prop_cup_dif_bad :: "forall a.\n(GHC.Classes.Ord a) =>\n(Data.Set.Base.Set a)\n-> (Data.Set.Base.Set a) -> {v : GHC.Types.Bool | Prop v}"
181:18-181:19::x :: "(Data.Set.Base.Set a)"
181:20-181:21::y :: "(Data.Set.Base.Set a)"
182:5-182:8::pre :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True && v == pre}"
182:9-182:18::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 => Prop v}"
182:20-182:21::x :: "{v : (Data.Set.Base.Set a) | v == x}"
182:22-182:24::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
182:26-182:54::lq_anf__d20c :: "(Data.Set.Base.Set a)"
182:27-182:28::x :: "{v : (Data.Set.Base.Set a) | v == x}"
182:29-182:36::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
182:37-182:38::y :: "{v : (Data.Set.Base.Set a) | v == y}"
182:40-182:52::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_dif x1 v}"
182:53-182:54::y :: "{v : (Data.Set.Base.Set a) | v == y}"
184:5-184:8::pre :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
184:11-184:15::_ :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
216:1-216:6::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
216:16-216:21::Data.Set.Base.empty :: "forall a. {v : (Data.Set.Base.Set a) | Set_emp v}"
217:16-217:25::_ :: "x1:a -> {v : (Data.Set.Base.Set a) | v == Set_sng x1}"
217:26-217:27::x :: "{VV : a | VV == x}"
217:28-217:35::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}"
217:36-217:41::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
217:42-217:44::xs :: "{v : [a] | v == xs && len v >= 0}"
249:1-249:8::Sets.append' :: "forall a.\nx1:[a]\n-> x2:[a] -> {v : [a] | elems v == Set_cup elems x1 elems x2}"
249:16-249:18::ys :: "[a]"
249:21-249:23::ys :: "{v : [a] | v == ys && len v >= 0}"
250:21-250:22::x :: "{VV : a | VV == x}"
250:23-250:24::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
250:25-250:32::Sets.append' :: "forall a.\nx1:[a]\n-> x2:[a] -> {v : [a] | elems v == Set_cup elems x1 elems x2}"
250:33-250:35::xs :: "{v : [a] | v == xs && len v >= 0}"
250:36-250:38::ys :: "{v : [a] | v == ys && len v >= 0}"
258:1-258:9::Sets.reverse' :: "forall a. x1:[a] -> {v : [a] | elems v == elems x1}"
258:10-258:12::xs :: "[a]"
258:15-258:24::Sets.revHelper :: "forall a. [a] -> [a] -> [a]"
258:25-258:27::lq_anf__d1ZF :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
258:28-258:30::xs :: "{v : [a] | v == xs && len v >= 0}"
260:1-260:10::Sets.revHelper :: "forall a. [a] -> [a] -> [a]"
260:11-260:14::acc :: "[a]"
260:24-260:27::acc :: "{v : [a] | v == acc && len v >= 0}"
261:24-261:33::Sets.revHelper :: "forall a. [a] -> [a] -> [a]"
261:35-261:36::x :: "{VV : a | VV == x}"
261:36-261:37::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
261:37-261:40::acc :: "{v : [a] | v == acc && len v >= 0}"
261:42-261:44::xs :: "{v : [a] | v == xs && len v >= 0}"
270:1-270:6::Sets.split :: "forall a. GHC.Types.Int -> [a] -> ([a], [a])"
270:9-270:11::xs :: "[a]"
270:20-270:28::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Prop>.\nx1:a\n-> x2:{VV : b<p2 x1> | true}\n-> {v : (a, b)<\\x6 VV -> p2 x6> | fst v == x1 && x_Tuple22 v == x2 && snd v == x2 && x_Tuple21 v == x1}"
270:21-270:23::lq_anf__d1Zr :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
270:25-270:27::xs :: "{v : [a] | v == xs && len v >= 0}"
271:20-271:32::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Prop>.\nx1:a\n-> x2:{VV : b<p2 x1> | true}\n-> {v : (a, b)<\\x6 VV -> p2 x6> | fst v == x1 && x_Tuple22 v == x2 && snd v == x2 && x_Tuple21 v == x1}"
271:21-271:22::x :: "{VV : a | VV == x}"
271:22-271:23::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
271:23-271:25::xs :: "{v : [a] | v == xs && len v >= 0}"
271:27-271:28::y :: "{VV : a | VV == y}"
271:28-271:29::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
271:29-271:31::ys :: "{v : [a] | v == ys && len v >= 0}"
271:40-271:42::xs :: "[a]"
271:44-271:46::ys :: "[a]"
271:50-271:55::Sets.split :: "forall a. GHC.Types.Int -> [a] -> ([a], [a])"
271:57-271:58::ds_d1X2 :: "GHC.Types.Int"
271:58-271:59::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
271:59-271:60::lq_anf__d1Zj :: "{v : GHC.Types.Int | v == (1  :  int)}"
271:62-271:64::zs :: "{v : [a] | v == zs && len v >= 0}"
272:20-272:28::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Prop>.\nx1:a\n-> x2:{VV : b<p2 x1> | true}\n-> {v : (a, b)<\\x6 VV -> p2 x6> | fst v == x1 && x_Tuple22 v == x2 && snd v == x2 && x_Tuple21 v == x1}"
272:21-272:23::lq_anf__d1Zi :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
272:25-272:27::xs :: "{v : [a] | v == xs && len v >= 0}"
275:1-275:18::Sets.prop_split_append :: "forall a.\n(GHC.Classes.Ord a) =>\nGHC.Types.Int -> [a] -> {v : GHC.Types.Bool | Prop v}"
275:19-275:20::n :: "GHC.Types.Int"
275:21-275:23::xs :: "[a]"
275:26-275:31::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
275:32-275:34::xs :: "{v : [a] | v == xs && len v >= 0}"
275:35-275:37::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
275:38-275:43::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
275:44-275:47::xs' :: "{v : [a] | v == xs' && elems v == Set_cup elems ys elems zs && len v >= 0}"
277:5-277:8::xs' :: "{v : [a] | elems v == Set_cup elems ys elems zs}"
277:17-277:24::Sets.append' :: "forall a.\nx1:[a]\n-> x2:[a] -> {v : [a] | elems v == Set_cup elems x1 elems x2}"
277:25-277:27::ys :: "{v : [a] | v == ys && v == ys && elems v == Set_cup elems ys elems ys && elems v == elems ys && len v == len ys && len v >= 0}"
277:28-277:30::zs :: "{v : [a] | v == zs && v == zs && elems v == Set_cup elems zs elems zs && elems v == elems zs && len v == len zs && len v >= 0}"
278:6-278:8::ys :: "{VV : [a] | VV == ys && elems VV == Set_cup elems ys elems ys && elems VV == elems ys && len VV == len ys && len VV >= 0}"
278:10-278:12::zs :: "{VV : [a] | VV == zs && elems VV == Set_cup elems zs elems zs && elems VV == elems zs && len VV == len zs && len VV >= 0}"
278:17-278:22::Sets.split :: "forall a. GHC.Types.Int -> [a] -> ([a], [a])"
278:23-278:24::n :: "{v : GHC.Types.Int | v == n}"
278:25-278:27::xs :: "{v : [a] | v == xs && len v >= 0}"
290:1-290:5::Sets.elem :: "forall a. (GHC.Classes.Eq a) => a -> [a] -> GHC.Types.Bool"
290:6-290:7::x :: "a"
290:17-290:18::x :: "{VV : a | VV == x}"
290:19-290:21::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
290:22-290:23::y :: "{VV : a | VV == y}"
290:24-290:26::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 || Prop v}"
290:27-290:31::Sets.elem :: "forall a. (GHC.Classes.Eq a) => a -> [a] -> GHC.Types.Bool"
290:32-290:33::x :: "{VV : a | VV == x}"
290:34-290:36::ys :: "{v : [a] | v == ys && len v >= 0}"
291:17-291:22::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
294:1-294:6::Sets.test1 :: "{v : GHC.Types.Bool | Prop v}"
294:14-294:18::Sets.elem :: "forall a. (GHC.Classes.Eq a) => a -> [a] -> GHC.Types.Bool"
294:21-294:28::lq_anf__d20D :: "{v : [GHC.Integer.Type.Integer] | null v <=> false && len v >= 0}"
297:1-297:6::Sets.test2 :: "{v : GHC.Types.Bool | not (Prop v)}"
297:14-297:18::Sets.elem :: "forall a. (GHC.Classes.Eq a) => a -> [a] -> GHC.Types.Bool"
297:21-297:26::lq_anf__d20v :: "{v : [GHC.Integer.Type.Integer] | null v <=> false && len v >= 0}"
319:1-319:7::Sets.insert :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:[a] -> {v : [a] | elems v == Set_cup Set_sng x2 elems x3}"
319:8-319:9::x :: "a"
319:19-319:22::lq_anf__d1Z3 :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
319:20-319:21::x :: "{VV : a | VV == x}"
321:5-321:6::x :: "{VV : a | VV == x}"
321:7-321:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 <= v}"
321:10-321:11::y :: "{VV : a | VV == y}"
321:19-321:20::x :: "{VV : a | VV == x}"
321:21-321:22::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
321:23-321:24::y :: "{VV : a | VV == y}"
321:25-321:26::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
321:27-321:29::ys :: "{v : [a] | v == ys && len v >= 0}"
322:19-322:20::y :: "{VV : a | VV == y}"
322:21-322:22::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
322:23-322:29::Sets.insert :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:[a] -> {v : [a] | elems v == Set_cup Set_sng x2 elems x3}"
322:30-322:31::x :: "{VV : a | VV == x}"
322:32-322:34::ys :: "{v : [a] | v == ys && len v >= 0}"
337:1-337:11::Sets.insertSort :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {v : [a] | elems v == elems x2}"
337:21-337:23::GHC.Types.[] :: "forall a <p :: a a -> Prop>.\n{v : [a]<\\x7 VV -> p x7> | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0}"
338:21-338:27::Sets.insert :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:a\n-> x3:[a] -> {v : [a] | elems v == Set_cup Set_sng x2 elems x3}"
338:28-338:29::x :: "{VV : a | VV == x}"
338:31-338:41::Sets.insertSort :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {v : [a] | elems v == elems x2}"
338:42-338:44::xs :: "{v : [a] | v == xs && len v >= 0}"
347:1-347:6::Sets.merge :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a]\n-> x3:[a] -> {v : [a] | elems v == Set_cup elems x2 elems x3}"
348:5-348:6::x :: "{VV : a | VV == x}"
348:7-348:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 <= v}"
348:10-348:11::y :: "{VV : a | VV == y}"
348:24-348:25::x :: "{VV : a | VV == x}"
348:26-348:27::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
348:28-348:33::Sets.merge :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a]\n-> x3:[a] -> {v : [a] | elems v == Set_cup elems x2 elems x3}"
348:34-348:36::xs :: "{v : [a] | v == xs && len v >= 0}"
348:38-348:39::y :: "{VV : a | VV == y}"
348:39-348:40::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
348:40-348:42::ys :: "{v : [a] | v == ys && len v >= 0}"
349:24-349:25::y :: "{VV : a | VV == y}"
349:26-349:27::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
349:28-349:33::Sets.merge :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a]\n-> x3:[a] -> {v : [a] | elems v == Set_cup elems x2 elems x3}"
349:35-349:36::x :: "{VV : a | VV == x}"
349:36-349:37::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
349:37-349:39::xs :: "{v : [a] | v == xs && len v >= 0}"
349:41-349:43::ys :: "{v : [a] | v == ys && len v >= 0}"
350:24-350:26::ds_d1WQ :: "{v : [a] | len v >= 0}"
351:24-351:26::ds_d1WP :: "{v : [a] | len v >= 0}"
354:1-354:15::Sets.prop_merge_app :: "forall a.\n(GHC.Classes.Ord a) =>\n[a] -> [a] -> {v : GHC.Types.Bool | Prop v}"
354:16-354:18::xs :: "[a]"
354:19-354:21::ys :: "[a]"
354:24-354:29::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
354:30-354:32::zs :: "{v : [a] | v == zs && elems v == Set_cup elems xs elems ys && len v >= 0}"
354:33-354:35::_ :: "x1:(Data.Set.Base.Set a)\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
354:36-354:41::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
354:42-354:45::zs' :: "{v : [a] | v == zs' && elems v == Set_cup elems xs elems ys && len v >= 0}"
356:5-356:7::zs :: "{v : [a] | elems v == Set_cup elems xs elems ys}"
356:24-356:31::Sets.append' :: "forall a.\nx1:[a]\n-> x2:[a] -> {v : [a] | elems v == Set_cup elems x1 elems x2}"
356:32-356:34::xs :: "{v : [a] | v == xs && len v >= 0}"
356:35-356:37::ys :: "{v : [a] | v == ys && len v >= 0}"
357:5-357:8::zs' :: "{v : [a] | elems v == Set_cup elems xs elems ys}"
357:24-357:29::Sets.merge :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a]\n-> x3:[a] -> {v : [a] | elems v == Set_cup elems x2 elems x3}"
357:32-357:34::xs :: "{v : [a] | v == xs && len v >= 0}"
357:35-357:37::ys :: "{v : [a] | v == ys && len v >= 0}"
366:1-366:10::Sets.mergeSort :: "forall a.\n(GHC.Classes.Ord a) =>\n[a] -> {v : [a] | elems v == Set_empty 0}"
366:17-366:19::GHC.Types.[] :: "forall a <p :: a a -> Prop>.\n{v : [a]<\\x7 VV -> p x7> | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0}"
367:17-367:22::Sets.merge :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a]\n-> x3:[a] -> {v : [a] | elems v == Set_cup elems x2 elems x3}"
367:24-367:33::Sets.mergeSort :: "forall a.\n(GHC.Classes.Ord a) =>\n[a] -> {v : [a] | elems v == Set_empty 0}"
367:34-367:36::ys :: "{v : [a] | v == ys && v == ys && elems v == Set_cup elems ys elems ys && elems v == elems ys && len v == len ys && len v >= 0}"
367:39-367:48::Sets.mergeSort :: "forall a.\n(GHC.Classes.Ord a) =>\n[a] -> {v : [a] | elems v == Set_empty 0}"
367:49-367:51::zs :: "{v : [a] | v == zs && v == zs && elems v == Set_cup elems zs elems zs && elems v == elems zs && len v == len zs && len v >= 0}"
369:5-369:7::ys :: "{VV : [a] | VV == ys && elems VV == Set_cup elems ys elems ys && elems VV == elems ys && len VV == len ys && len VV >= 0}"
369:9-369:11::zs :: "{VV : [a] | VV == zs && elems VV == Set_cup elems zs elems zs && elems VV == elems zs && len VV == len zs && len VV >= 0}"
369:17-369:22::Sets.split :: "forall a. GHC.Types.Int -> [a] -> ([a], [a])"
369:23-369:26::mid :: "{v : GHC.Types.Int | v == mid}"
369:27-369:29::ds_d1Xe :: "{v : [a] | len v >= 0}"
370:4-370:7::mid :: "GHC.Types.Int"
370:17-370:23::_ :: "x1:[a] -> {v : GHC.Types.Int | v == len x1}"
370:24-370:26::ds_d1Xe :: "{v : [a] | len v >= 0}"
370:27-370:32::_ :: "x1:GHC.Types.Int\n-> x2:{v : GHC.Types.Int | v /= 0}\n-> {v : GHC.Types.Int | x1 >= 0 && x2 >= 0 => v >= 0 && x1 >= 0 && x2 >= 1 => v <= x1 && v == x1 / x2}"
370:33-370:34::lq_anf__d1Zu :: "{v : GHC.Types.Int | v == (2  :  int)}"
399:1-399:7::Sets.unique :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : GHC.Types.Bool | Prop VV <=> unique x2}"
399:17-399:21::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
400:17-400:23::Sets.unique :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : GHC.Types.Bool | Prop VV <=> unique x2}"
400:24-400:26::xs :: "{v : [a] | v == xs && len v >= 0}"
400:27-400:29::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 && Prop v}"
400:30-400:33::_ :: "x1:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> not (Prop x1)}"
400:35-400:41::_ :: "x1:a\n-> x2:(Data.Set.Base.Set a)\n-> {v : GHC.Types.Bool | Prop v <=> Set_mem x1 v}"
400:42-400:43::x :: "{VV : a | VV == x}"
400:45-400:50::Sets.elems :: "forall a.\n(GHC.Classes.Ord a) =>\nx2:[a] -> {VV : (Data.Set.Base.Set a) | VV == elems x2}"
400:51-400:53::xs :: "{v : [a] | v == xs && len v >= 0}"
414:1-414:9::Sets.isUnique :: "{v : [GHC.Types.Int] | unique v}"
414:19-414:28::lq_anf__d1YQ :: "{v : [GHC.Types.Int] | null v <=> false && len v >= 0}"
414:20-414:21::lq_anf__d1YL :: "{v : GHC.Types.Int | v == (1  :  int)}"
414:23-414:24::lq_anf__d1YM :: "{v : GHC.Types.Int | v == (2  :  int)}"
414:26-414:27::lq_anf__d1YN :: "{v : GHC.Types.Int | v == (3  :  int)}"
417:1-417:12::Sets.isNotUnique :: "{v : [GHC.Types.Int] | unique v}"
417:19-417:31::lq_anf__d1YK :: "{v : [GHC.Types.Int] | null v <=> false && len v >= 0}"
417:20-417:21::lq_anf__d1YD :: "{v : GHC.Types.Int | v == (1  :  int)}"
417:23-417:24::lq_anf__d1YE :: "{v : GHC.Types.Int | v == (2  :  int)}"
417:26-417:27::lq_anf__d1YF :: "{v : GHC.Types.Int | v == (3  :  int)}"
417:29-417:30::lq_anf__d1YG :: "{v : GHC.Types.Int | v == (1  :  int)}"
426:1-426:7::Sets.filter :: "forall a.\n(a -> GHC.Types.Bool)\n-> x3:{v : [a] | unique v}\n-> {v : [a] | Set_sub elems v elems x3 && unique v}"
426:19-426:21::GHC.Types.[] :: "forall a <p :: a a -> Prop>.\n{v : [a]<\\x7 VV -> p x7> | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0}"
428:5-428:6::_ :: "a -> GHC.Types.Bool"
428:7-428:8::x :: "{VV : a | VV == x}"
428:19-428:20::x :: "{VV : a | VV == x}"
428:21-428:22::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
428:23-428:26::xs' :: "{v : [a] | Set_sub elems v elems xs && unique v && v == xs' && len v >= 0}"
429:19-429:22::_ :: "{v : [a] | Set_sub elems v elems xs && unique v && v == xs' && len v >= 0}"
431:5-431:8::xs' :: "{v : [a] | Set_sub elems v elems xs && unique v}"
431:19-431:25::Sets.filter :: "forall a.\n(a -> GHC.Types.Bool)\n-> x3:{v : [a] | unique v}\n-> {v : [a] | Set_sub elems v elems x3 && unique v}"
431:26-431:27::ds_d1WI :: "a -> GHC.Types.Bool"
431:28-431:30::xs :: "{v : [a] | v == xs && len v >= 0}"
442:1-442:8::Sets.reverse :: "forall a. {v : [a] | unique v} -> {v : [a] | unique v}"
442:19-442:21::_ :: "[a] -> [a] -> [a]"
442:22-442:24::lq_anf__d1Y5 :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
445:5-445:7::go :: "forall a. [a] -> [a] -> [a]"
445:8-445:9::a :: "[a]"
445:19-445:20::a :: "{v : [a] | v == a && len v >= 0}"
446:19-446:21::go :: "[a] -> [a] -> [a]"
446:23-446:24::x :: "{VV : a | VV == x}"
446:24-446:25::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
446:25-446:26::a :: "{v : [a] | v == a && len v >= 0}"
446:28-446:30::xs :: "{v : [a] | v == xs && len v >= 0}"
454:1-454:4::Sets.nub :: "forall a. (GHC.Classes.Eq a) => [a] -> [a]"
454:5-454:7::xs :: "[a]"
454:25-454:27::_ :: "[a] -> [a] -> [a]"
454:28-454:30::lq_anf__d1Y2 :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
454:31-454:33::xs :: "{v : [a] | v == xs && len v >= 0}"
456:5-456:7::go :: "forall a. (GHC.Classes.Eq a) => [a] -> [a] -> [a]"
456:8-456:12::seen :: "[a]"
456:25-456:29::seen :: "{v : [a] | v == seen && len v >= 0}"
458:9-458:10::x :: "{VV : a | VV == x}"
458:11-458:17::Sets.isin :: "forall a.\n(GHC.Classes.Eq a) =>\nx2:a\n-> x3:[a] -> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 elems x3}"
458:18-458:22::seen :: "{v : [a] | v == seen && len v >= 0}"
458:25-458:27::go :: "[a] -> [a] -> [a]"
458:28-458:32::seen :: "{v : [a] | v == seen && len v >= 0}"
458:37-458:39::xs :: "{v : [a] | v == xs && len v >= 0}"
459:25-459:27::go :: "[a] -> [a] -> [a]"
459:29-459:30::x :: "{VV : a | VV == x}"
459:30-459:31::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
459:31-459:35::seen :: "{v : [a] | v == seen && len v >= 0}"
459:37-459:39::xs :: "{v : [a] | v == xs && len v >= 0}"
469:1-469:5::Sets.isin :: "forall a.\n(GHC.Classes.Eq a) =>\nx2:a\n-> x3:[a] -> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 elems x3}"
469:6-469:7::x :: "a"
470:5-470:6::x :: "{VV : a | VV == x}"
470:7-470:9::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
470:10-470:11::y :: "{VV : a | VV == y}"
470:17-470:21::GHC.Types.True :: "{v : GHC.Types.Bool | Prop v && v == GHC.Types.True}"
471:17-471:18::x :: "{VV : a | VV == x}"
471:19-471:25::Sets.isin :: "forall a.\n(GHC.Classes.Eq a) =>\nx2:a\n-> x3:[a] -> {v : GHC.Types.Bool | Prop v <=> Set_mem x2 elems x3}"
471:26-471:28::ys :: "{v : [a] | v == ys && len v >= 0}"
472:17-472:22::GHC.Types.False :: "{v : GHC.Types.Bool | not (Prop v) && v == GHC.Types.False}"
482:1-482:7::Sets.append :: "forall a.\n{v : [a] | unique v}\n-> {v : [a] | unique v} -> {v : [a] | unique v}"
482:15-482:17::ys :: "{v : [a] | unique v}"
482:20-482:22::ys :: "{v : [a] | unique v && v == ys && len v >= 0}"
483:20-483:21::x :: "{VV : a | VV == x}"
483:22-483:23::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
483:24-483:30::Sets.append :: "forall a.\n{v : [a] | unique v}\n-> {v : [a] | unique v} -> {v : [a] | unique v}"
483:31-483:33::xs :: "{v : [a] | v == xs && len v >= 0}"
483:34-483:36::ys :: "{v : [a] | unique v && v == ys && len v >= 0}"
497:1-497:6::Sets.range :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int\n-> {v : [{v : GHC.Types.Int | v < x2 && x1 <= v}] | unique v}"
497:7-497:8::i :: "GHC.Types.Int"
497:9-497:10::j :: "GHC.Types.Int"
498:5-498:6::i :: "{v : GHC.Types.Int | v == i}"
498:7-498:8::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
498:9-498:10::j :: "{v : GHC.Types.Int | v == j}"
498:17-498:18::i :: "{v : GHC.Types.Int | v == i}"
498:19-498:20::_ :: "x1:{v : GHC.Types.Int | v >= i && v < j}\n-> x2:[{v : GHC.Types.Int | v > x1 && v > i && v >= i && v < j}]<\\x20 VV -> v > x20 && v > i && v < j>\n-> {v : [{v : GHC.Types.Int | v >= i && v < j}]<\\x11 VV -> v > x11 && v > i && v < j> | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
498:21-498:26::Sets.range :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int\n-> {v : [{v : GHC.Types.Int | v < x2 && x1 <= v}] | unique v}"
498:28-498:29::i :: "{v : GHC.Types.Int | v == i}"
498:30-498:31::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
498:32-498:33::lq_anf__d20G :: "{v : GHC.Types.Int | v == (1  :  int)}"
498:35-498:36::j :: "{v : GHC.Types.Int | v == j}"
499:17-499:19::_ :: "{v : [{v : GHC.Types.Int | false}] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0}"
516:5-516:10::Sets.focus :: "forall a. (Sets.Zipper a) -> a"
517:5-517:9::Sets.left :: "forall a. (Sets.Zipper a) -> [a]"
518:5-518:10::Sets.right :: "forall a. (Sets.Zipper a) -> [a]"
549:1-549:14::Sets.differentiate :: "forall a.\n{v : [a] | unique v} -> (Data.Maybe.Maybe (Sets.Zipper a))"
549:24-549:31::Data.Maybe.Nothing :: "forall a. {v : (Data.Maybe.Maybe a) | isJust v <=> false}"
550:24-550:28::lq_anf__d1XQ :: "x1:(Sets.Zipper a)\n-> {v : (Data.Maybe.Maybe (Sets.Zipper a)) | isJust v <=> true && fromJust v == x1}"
550:29-550:30::_ :: "((Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a)))\n-> (Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a))"
550:31-550:37::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
550:38-550:39::x :: "{VV : a | VV == x}"
550:40-550:42::lq_anf__d1XR :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
550:43-550:45::xs :: "{v : [a] | v == xs && len v >= 0}"
560:1-560:10::Sets.integrate :: "forall a. (Sets.Zipper a) -> {v : [a] | unique v}"
560:28-560:35::_ :: "{v : [a] | unique v} -> {v : [a] | unique v}"
560:36-560:37::l :: "{v : [a] | not (Set_mem x elems v) && unique v && v == l && len v >= 0}"
560:38-560:46::Sets.append :: "forall a.\n{v : [a] | unique v}\n-> {v : [a] | unique v} -> {v : [a] | unique v}"
560:48-560:49::x :: "{VV : a | VV == x}"
560:50-560:51::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
560:52-560:53::r :: "{v : [a] | not (Set_mem x elems v) && unique v && v == r && Set_empty 0 == Set_cap elems v elems l && len v >= 0}"
568:1-568:10::Sets.focusLeft :: "forall a. (Sets.Zipper a) -> (Sets.Zipper a)"
568:34-568:40::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
568:41-568:42::x :: "{VV : a | VV == x && VV == x}"
568:43-568:45::xs :: "{v : [a] | unique v && v == xs && v == xs && elems v == Set_cup elems xs elems xs && elems v == elems xs && len v == len xs && len v >= 0}"
568:46-568:48::lq_anf__d1Yi :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
568:60-568:61::x :: "{VV : a | VV == x}"
568:62-568:64::xs :: "{VV : [a] | unique VV && VV == xs && elems VV == Set_cup elems xs elems xs && elems VV == elems xs && len VV == len xs && len VV >= 0}"
568:68-568:75::_ :: "{v : [a] | unique v} -> {v : [a] | unique v}"
568:77-568:78::t :: "{VV : a | VV == t}"
568:78-568:79::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
568:79-568:81::rs :: "{v : [a] | not (Set_mem t elems v) && unique v && v == rs && len v >= 0}"
569:34-569:40::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
569:41-569:42::l :: "{VV : a | VV == l}"
569:43-569:45::ls :: "{v : [a] | v == ls && len v >= 0}"
569:47-569:48::t :: "{VV : a | VV == t}"
569:48-569:49::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
569:49-569:51::rs :: "{v : [a] | not (Set_mem t elems v) && unique v && v == rs && len v >= 0}"
572:1-572:11::Sets.focusRight :: "forall a. (Sets.Zipper a) -> (Sets.Zipper a)"
572:34-572:47::lq_anf__d1Yk :: "(Sets.Zipper a) -> (Sets.Zipper a)"
572:48-572:49::_ :: "((Sets.Zipper a) -> (Sets.Zipper a))\n-> ((Sets.Zipper a) -> (Sets.Zipper a))\n-> (Sets.Zipper a)\n-> exists [(Sets.Zipper a)].(Sets.Zipper a)"
572:50-572:59::lq_anf__d1Yl :: "(Sets.Zipper a) -> (Sets.Zipper a)"
572:60-572:61::_ :: "((Sets.Zipper a) -> (Sets.Zipper a))\n-> ((Sets.Zipper a) -> (Sets.Zipper a))\n-> (Sets.Zipper a)\n-> exists [(Sets.Zipper a)].(Sets.Zipper a)"
572:62-572:75::lq_anf__d1Ym :: "(Sets.Zipper a) -> (Sets.Zipper a)"
575:1-575:14::Sets.reverseZipper :: "forall a. (Sets.Zipper a) -> (Sets.Zipper a)"
575:34-575:40::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
575:41-575:42::t :: "{VV : a | VV == t}"
575:43-575:45::rs :: "{v : [a] | not (Set_mem t elems v) && unique v && v == rs && Set_empty 0 == Set_cap elems v elems ls && len v >= 0}"
575:46-575:48::ls :: "{v : [a] | not (Set_mem t elems v) && unique v && v == ls && len v >= 0}"
583:1-583:13::Sets.filterZipper :: "forall a.\n(a -> GHC.Types.Bool)\n-> (Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a))"
583:14-583:15::p :: "a -> GHC.Types.Bool"
583:40-583:46::Sets.filter :: "forall a.\n(a -> GHC.Types.Bool)\n-> x3:{v : [a] | unique v}\n-> {v : [a] | Set_sub elems v elems x3 && unique v}"
583:47-583:48::p :: "a -> GHC.Types.Bool"
583:50-583:51::f :: "{VV : a | VV == f}"
583:51-583:52::_ :: "x1:a\n-> x2:[a]\n-> {v : [a] | unique v <=> unique x2 && not (Set_mem x1 elems x2) && null v <=> false && xListSelector v == x1 && elems v == Set_cup Set_sng x1 elems x2 && listElts v == Set_cup Set_sng x1 listElts x2 && xsListSelector v == x2 && len v == 1 + len x2}"
583:52-583:54::rs :: "{v : [a] | not (Set_mem f elems v) && unique v && v == rs && Set_empty 0 == Set_cap elems v elems ls && len v >= 0}"
584:15-584:19::lq_anf__d1YA :: "x1:(Sets.Zipper a)\n-> {v : (Data.Maybe.Maybe (Sets.Zipper a)) | isJust v <=> true && fromJust v == x1}"
584:20-584:21::_ :: "((Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a)))\n-> (Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a))"
584:22-584:28::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
584:29-584:31::f' :: "{VV : a | VV == f'}"
584:33-584:39::Sets.filter :: "forall a.\n(a -> GHC.Types.Bool)\n-> x3:{v : [a] | unique v}\n-> {v : [a] | Set_sub elems v elems x3 && unique v}"
584:40-584:41::p :: "a -> GHC.Types.Bool"
584:42-584:44::ls :: "{v : [a] | not (Set_mem f elems v) && unique v && v == ls && len v >= 0}"
584:46-584:49::rs' :: "{v : [a] | v == rs' && len v >= 0}"
585:20-585:26::Sets.filter :: "forall a.\n(a -> GHC.Types.Bool)\n-> x3:{v : [a] | unique v}\n-> {v : [a] | Set_sub elems v elems x3 && unique v}"
585:27-585:28::p :: "a -> GHC.Types.Bool"
585:29-585:31::ls :: "{v : [a] | not (Set_mem f elems v) && unique v && v == ls && len v >= 0}"
586:31-586:35::lq_anf__d1Yx :: "x1:(Sets.Zipper a)\n-> {v : (Data.Maybe.Maybe (Sets.Zipper a)) | isJust v <=> true && fromJust v == x1}"
586:36-586:37::_ :: "((Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a)))\n-> (Sets.Zipper a) -> (Data.Maybe.Maybe (Sets.Zipper a))"
586:38-586:44::_ :: "x1:a\n-> x2:{v : [a] | not (Set_mem x1 elems v) && unique v}\n-> x3:{v : [a] | not (Set_mem x1 elems v) && unique v && Set_empty 0 == Set_cap elems v elems x2}\n-> {v : (Sets.Zipper a) | left v == x2 && right v == x3 && focus v == x1}"
586:45-586:47::f' :: "{VV : a | VV == f'}"
586:48-586:51::ls' :: "{v : [a] | v == ls' && len v >= 0}"
586:52-586:54::lq_anf__d1Yy :: "{v : [a] | unique v <=> true && null v <=> true && Set_emp listElts v && elems v == Set_empty 0 && len v == 0 && len v >= 0}"
587:31-587:38::Data.Maybe.Nothing :: "forall a. {v : (Data.Maybe.Maybe a) | isJust v <=> false}"
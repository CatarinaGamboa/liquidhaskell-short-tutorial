<p>\begin{comment}</p>
<pre><span class=hs-linenum>13: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Introduction</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>14: </span><a class=annot href="#"><span class=annottext>(GHC.Types.IO ()^"lq_tmp_x35")^"lq_tmp_x36"</span><span class='hs-definition'>main</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x192:[GHC.Types.Char^"lq_tmp_x13"]&lt;\lq_tmp_x186 VV -&gt; True&gt;^"lq_tmp_x15"
-&gt; (GHC.Types.IO ()^"lq_tmp_x16")^"lq_tmp_x17"</span><span class='hs-varid'>putStrLn</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x196 : [GHC.Types.Char^"lq_tmp_x2"]&lt;\lq_tmp_x194 VV -&gt; True&gt;^"lq_tmp_x4" | len lq_tmp_x196 &gt;= 0 &amp;&amp; lq_tmp_x196 == lq_anf__dUw}</span><span class='hs-str'>"Intro"</span></a>
</pre>
<p>\end{comment}</p>
<h1 id="intro">Introduction</h1>
<p>One of the great things about Haskell is its brainy type system that allows one to enforce a variety of invariants at compile time, thereby nipping, in the bud, a large swathe of run-time errors.</p>
<h2 id="well-typed-programs-do-go-wrong">Well-Typed Programs Do Go Wrong</h2>
<p>Alas, well-typed programs <em>do</em> go quite wrong, in a variety of ways.</p>
<p> This innocuous function computes the average of a list of integers:</p>
<pre><span class=hs-linenum>36: </span><span class='hs-definition'>average</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>37: </span><a class=annot href="#"><span class=annottext>lq_tmp_x198:[GHC.Types.Int^"lq_tmp_x38"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x40"
-&gt; GHC.Types.Int^"lq_tmp_x41"</span><span class='hs-definition'>average</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int^"lq_tmp_x38"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x40"</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x206:[GHC.Types.Int^"lq_tmp_x207" "lq_tmp_x26"]&lt;\lq_tmp_x201 VV -&gt; True&gt;^"lq_tmp_x28"
-&gt; GHC.Types.Int^"lq_tmp_x207" "lq_tmp_x29"</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x214 : [GHC.Types.Int^"lq_tmp_x38"]&lt;\lq_tmp_x212 VV -&gt; True&gt;^"lq_tmp_x40" | len lq_tmp_x214 &gt;= 0 &amp;&amp; lq_tmp_x214 == xs#aUj}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x235:GHC.Types.Int^"lq_tmp_x237"
-&gt; lq_tmp_x236:{lq_tmp_x238 : GHC.Types.Int^"lq_tmp_x237" | lq_tmp_x238 /= 0}
-&gt; {lq_tmp_x238 : GHC.Types.Int^"lq_tmp_x237" | lq_tmp_x238 == lq_tmp_x235 / lq_tmp_x236 &amp;&amp; lq_tmp_x235 &gt;= 0 &amp;&amp; lq_tmp_x236 &gt;= 0 =&gt; lq_tmp_x238 &gt;= 0 &amp;&amp; lq_tmp_x235 &gt;= 0 &amp;&amp; lq_tmp_x236 &gt;= 1 =&gt; lq_tmp_x238 &lt;= lq_tmp_x235}</span><span class='hs-varop'>`div`</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>lq_tmp_x220:[{lq_tmp_x224 : GHC.Types.Int^"lq_tmp_x223" | k_222[VV#221:=lq_tmp_x224]}]
-&gt; {lq_tmp_x218 : GHC.Types.Int | lq_tmp_x218 == len lq_tmp_x220}</span><span class='hs-varid'>length</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp_x228 : [GHC.Types.Int^"lq_tmp_x38"]&lt;\lq_tmp_x226 VV -&gt; True&gt;^"lq_tmp_x40" | len lq_tmp_x228 &gt;= 0 &amp;&amp; lq_tmp_x228 == xs#aUj}</span><span class='hs-varid'>xs</span></a></span>
</pre>
<p>When run with a non-empty list of numbers, we get the desired result:</p>

However, if we call it with an empty list, we get a rather unpleasant crash: 

<p> Associative key-value maps are the new lists; they come &quot;built-in&quot; with modern languages like Go, Python, JavaScript and Lua; and of course, they're widely used in Haskell too.</p>

<p>Alas, maps are another source of vexing errors that are tickled when we try to find the value of an absent key:</p>

<p></p>
<p> Say what? How can one possibly get a segmentation fault with a <em>safe</em> language like Haskell. Well, here's the thing: every safe language is built on a foundation of machine code, or at the very least, <code>C</code>. Consider the ubiquitous <code>vector</code> library:</p>

<p>However, invalid inputs at the safe upper levels could percolate all the way down and stir a mutiny down below:</p>

<p></p>
<p> Finally, for certain kinds of programs, there is a fate worse than death. <code>text</code> is a high-performance string processing library for Haskell, that is used, for example, to build web services.</p>

<p>A cunning adversary can use invalid, or rather, <em>well-crafted</em>, inputs that go well outside the size of the given text` to read extra bytes and thus <em>extract secrets</em> without anyone being any the wiser.</p>

<p>The above call returns the bytes residing in memory <em>immediately after</em> the string <code>Voltage</code>. These bytes could be junk, or could be either the name of your favorite TV show, or, more worryingly, your bank account password.</p>
<h2 id="refinement-types">Refinement Types</h2>
<p>Refinement types allow us to enrich Haskell's type system with <em>predicates</em> which precisely describe the sets of <em>valid</em> inputs and outputs of functions, and values held inside containers and so on. These predicates are drawn from special <em>logics</em> for which there are fast <em>decision procedures</em> called SMT solvers.</p>
<p> you can specify <em>contracts</em> which describe valid inputs and outputs of functions. The refinement type system <em>guarantees at compile time</em> that functions adhere to their contracts. That is, you can rest assured that the above calamities <em>cannot occur at run-time</em>.</p>
<p> is a Refinement Type Checker for Haskell, and in this document we'll describe how you can use it to make programs better and programming even more fun.</p>
<p></p>
<h2 id="audience">Audience</h2>
<p>Do you</p>
<ul>
<li>know a bit of basic arithmetic and logic?</li>
<li>know the difference between a <code>nand</code> and an <code>xor</code>?</li>
<li>know any typed languages e.g. ML, Haskell, Scala, F# or Racket?</li>
<li>know what <code>forall a. a -&gt; a</code> means?</li>
<li>like it when your code editor politely points out infinite loops?</li>
<li>like your programs to not have bugs?</li>
</ul>
<p>Then this tutorial is for you!</p>
<h2 id="getting-started">Getting Started</h2>
<p>First things first; lets see how to install and run LiquidHaskell.</p>
<p> LiquidHaskell requires, in addition to the cabal dependencies the binary executable for an <code>SMTLIB2</code> compatible solver, e.g. one of</p>
<ul>
<li><a href="http://z3.codeplex.com/">Z3</a></li>
<li><a href="http://cvc4.cs.nyu.edu/">CVC4</a></li>
<li><a href="http://mathsat.fbk.eu/download.html">MathSat</a></li>
</ul>
<p> Once you have the above on your system, simply do:</p>

<p>You will see a report of <code>SAFE</code> or <code>UNSAFE</code> together with type errors at various points in the source.</p>
<p> have LiquidHaskell plugins, which run <code>liquid</code> in the background as you edit any Haskell file, highlight errors, and display the inferred types, all of which we find to be extremely useful. Hence we <em>strongly recommend</em> these over the command line option.</p>
<ul>
<li>Emacs' <code>flycheck</code> plugin is described <a href="https://github.com/ucsd-progsys/liquidhaskell#emacs">here</a></li>
<li>Vim's <code>syntastic</code> checker is described <a href="https://github.com/ucsd-progsys/liquidhaskell#vim">here</a></li>
</ul>
<h2 id="sample-code">Sample Code</h2>
<p>This entire tutorial is written in literate Haskell. All the code for it is available <a href="http://github.com/ucsd-pl/liquidhaskell-tutorial.git">on github</a>. We <em>strongly</em> recommend you grab the code, and follow along at home, and especially, that you do the various exercises.</p>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

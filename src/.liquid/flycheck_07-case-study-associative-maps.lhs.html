<h1 id="case-study-associative-maps">Case Study: Associative Maps</h1>


<p>Recall the following from the <a href="#intro">introduction</a>.</p>

<p>The problem illustrated above is quite a pervasive one; associative maps pop up everywhere. Failed lookups are the equivalent of <code>NullPointerDereference</code> exceptions in languages like Haskell. It is rather difficult to use Haskell's type system to precisely characterize the behavior of associative map APIs as ultimately, this requires tracking the <em>dynamic set of keys</em> in the map.</p>
<p>In this case study, we'll see how to combine two techniques -- <a href="#setmeasure">measures</a> for reasoning about the <em>sets</em> of elements in structures, and <a href="#refineddatatypes">refined data types</a> for reasoning about order invariants -- can be applied to programs that use associative maps (e.g. <code>Data.Map</code> or <code>Data.HashMap</code>).</p>
<h2 id="mapapi">Specifying Maps</h2>
<p>Lets start by defining a <em>refined API</em> for Associative Maps that tracks the set of keys stored in the map, in order to statically ensure the safety of lookups.</p>
<p> First, we need an (currently abstract) type for <code>Map</code>s. As usual, lets parameterize the type with <code>k</code> for the type of keys and <code>v</code> for the type of values.</p>
<pre><span class=hs-linenum>91: </span><span class='hs-comment'>-- | Data Type</span>
<span class=hs-linenum>92: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span>
</pre>
<p> To talk about the set of keys in a map, we will use a <em>measure</em></p>
<pre><span class=hs-linenum>99: </span><span class='hs-definition'>measure</span> <span class='hs-varid'>keys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>k</span>
</pre>
<p>that associates each <code>Map</code> to the <code>Set</code> of its defined keys. Next, we use the above measure, and the usual <code>Set</code> operators to refine the types of the functions that <em>create</em>, <em>add</em> and <em>lookup</em> key-value bindings, in order to precisely track, within the type system, the <code>keys</code> that are dynamically defined within each <code>Map</code>.</p>
<p> <code>Map</code>s have no keys in them. Hence, we defined a predicate alias, <code>NoKey</code> and use it to type <code>emp</code> which is used to denote the empty <code>Map</code>:</p>
<pre><span class=hs-linenum>114: </span><span class='hs-definition'>emp</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NoKey</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>NoKey</span> <span class='hs-conid'>M</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keys</span> <span class='hs-conid'>M</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_empty</span> <span class='hs-num'>0</span>
</pre>
<p> The function <code>set</code> takes a key <span class="math"><em>k</em></span> a value <span class="math"><em>v</em></span> and a map <code>m</code> and returns the new map obtained by extending <code>m</code> with the binding <span class="math"><em>k</em> ↦ <em>v</em></span>. Thus, the set of <code>keys</code> of the output <code>Map</code> includes those of the input plus the singleton <span class="math"><em>k</em></span>, that is:</p>
<pre><span class=hs-linenum>126: </span><span class='hs-definition'>set</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>n</span><span class='hs-conop'>:</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlusKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span><span class='hs-layout'>}</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>PlusKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keys</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_sng</span> <span class='hs-conid'>K</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>
</pre>
<p> Finally, queries will only succeed for keys that are defined a given <code>Map</code>. Thus, we define an alias:</p>
<pre><span class=hs-linenum>135: </span><span class='hs-definition'>predicate</span> <span class='hs-conid'>HasKey</span> <span class='hs-conid'>K</span> <span class='hs-conid'>M</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_mem</span> <span class='hs-conid'>K</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>M</span><span class='hs-layout'>)</span>
</pre>
<p>and use it to type <code>mem</code> which <em>checks</em> if a key is defined in the <code>Map</code> and <code>get</code> which actually returns the value associated with a given key.</p>
<pre><span class=hs-linenum>143: </span><span class='hs-comment'>-- | Check if key is defined </span>
<span class=hs-linenum>144: </span><span class='hs-definition'>mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Prop</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;=&gt;</span> <span class='hs-conid'>HasKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span><span class='hs-comment'>-- | Lookup key's value </span>
<span class=hs-linenum>147: </span><span class='hs-definition'>get</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HasKey</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span>
</pre>
<h2 id="using-maps-well-scoped-expressions">Using Maps: Well Scoped Expressions</h2>
<p>Rather than jumping into the <em>implementation</em> of the above <code>Map</code> API, lets write a <em>client</em> that uses <code>Map</code>s to implement an interpreter for a tiny language. In particular, we will use maps as an <em>environment</em> containing the values of <em>bound variables</em>, and we will use the refined API to ensure that <em>lookups never fail</em>, and hence, that well-scoped programs always reduce to a value.</p>
<p> Lets work with a simple language with integer constants, variables, binding and arithmetic operators: </p>
<pre><span class=hs-linenum>166: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>String</span> 
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Const</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>169: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Var</span>   <span class='hs-conid'>Var</span>
<span class=hs-linenum>170: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Plus</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
<span class=hs-linenum>171: </span>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Let</span>   <span class='hs-conid'>Var</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
</pre>
<p> We can use refinements to formally describe <em>values</em> as a subset of <code>Expr</code> allowing us to reuse a bunch of code. To this end, we simply define a (<code>measure</code>) predicate characterizing values:</p>
<pre><span class=hs-linenum>180: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>181: </span><span class='hs-definition'>val</span>              <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> 
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; val x1}</span><span class='hs-definition'>val</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a> 
<span class=hs-linenum>183: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a> 
<span class=hs-linenum>184: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a> 
<span class=hs-linenum>185: </span><span class='hs-definition'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a> 
</pre>
<p>and then we can use the lifted <code>measure</code> to define an alias for <code>Val</code> denoting values:</p>
<pre><span class=hs-linenum>192: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>val</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>we can use the above to write simple <em>operators</em> on <code>Val</code>, for example:</p>
<pre><span class=hs-linenum>199: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plus</span>                 <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>200: </span><a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v}
-&gt; {v : AssocativeMap.Expr | val v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>plus</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; free v == Set_empty 0}</span><span class='hs-conid'>Const</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == i}</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == j}</span><span class='hs-varid'>j</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>201: </span><span class='hs-definition'>plus</span> <span class='hs-keyword'>_</span>         <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false} -&gt; {v : AssocativeMap.Expr | false}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-str'>"Bad call to plus"</span></a>
</pre>
<p> let us save values for the &quot;local&quot; i.e. <em>let-bound</em> variables; when evaluating an expression <code>Var x</code> we simply look up the value of <code>x</code> in the environment. This is why <code>Map</code>s were invented! Lets define our environments as <code>Map</code>s from <code>Var</code>iables to <code>Val</code>ues:</p>
<pre><span class=hs-linenum>211: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Map</span> <span class='hs-conid'>Var</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>The above definition essentially specifies, inside the types, an <em>eager</em> evaluation strategy: LiquidHaskell will prevent us from sticking unevaluated <code>Expr</code>s inside the environments.</p>
<p> proceeds via a straightforward recursion over the structure of the expression. When we hit a <code>Var</code> we simply query its value from the environment. When we hit a <code>Let</code> we compute the bound expression and tuck its value into the environment before proceeding within.</p>
<pre><span class=hs-linenum>225: </span><a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; {v : AssocativeMap.Expr | Set_sub free v keys x1}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>eval</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>AssocativeMap.Expr</span><span class='hs-varid'>i</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; v == i &amp;&amp; free v == Set_empty 0}</span><span class='hs-varid'>i</span></a>
<span class=hs-linenum>226: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> 
<span class=hs-linenum>227: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v}
-&gt; {v : AssocativeMap.Expr | val v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>plus</span></a>  <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})
-&gt; {VV : AssocativeMap.Expr | Set_sub free VV keys x1}
-&gt; {VV : AssocativeMap.Expr | val VV}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e1}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})
-&gt; {VV : AssocativeMap.Expr | Set_sub free VV keys x1}
-&gt; {VV : AssocativeMap.Expr | val VV}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e2}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span> 
<span class=hs-linenum>228: </span><span class='hs-definition'>eval</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})
-&gt; {VV : AssocativeMap.Expr | Set_sub free VV keys x1}
-&gt; {VV : AssocativeMap.Expr | val VV}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v &amp;&amp; v /= i}) | v == g'}</span><span class='hs-varid'>g'</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e2}</span><span class='hs-varid'>e2</span></a> 
<span class=hs-linenum>229: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>230: </span>    <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v &amp;&amp; v /= i})</span><span class='hs-varid'>g'</span></a>               <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; b
-&gt; x4:(AssocativeMap.Map a b)
-&gt; {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &amp;&amp; v == v1}</span><span class='hs-varid'>v1</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> 
<span class=hs-linenum>231: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>v1</span></a>               <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {VV : AssocativeMap.Expr | val VV})
-&gt; {VV : AssocativeMap.Expr | Set_sub free VV keys x1}
-&gt; {VV : AssocativeMap.Expr | val VV}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e1}</span><span class='hs-varid'>e1</span></a>
</pre>
<p>The above <code>eval</code> seems rather unsafe; whats the guarantee that <code>get x g</code> will succeed? For example, surely trying:</p>

<p>will lead to some unpleasant crash. Shouldn't we <em>check</em> if the variables is present and if not, fail with some sort of <code>Variable Not Bound</code> error? We could, but we can do better: we can prove at compile time, that such errors will not occur.</p>
<p> are those whose values are <em>not</em> bound within an expression, that is, the set of variables that <em>appear</em> in the expression, but are not <em>bound</em> by a dominating <code>Let</code>. We can formalize this notion as a (lifted) function:</p>
<pre><span class=hs-linenum>252: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>free</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>253: </span><span class='hs-definition'>free</span>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>254: </span><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}</span><span class='hs-definition'>free</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Const</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. {v : (Data.Set.Base.Set a) | Set_emp v}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>255: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[GHC.Types.Char]
-&gt; {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_sng x1}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>256: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Plus</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e1}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; x2:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_cup x1 v}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e2}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>257: </span><span class='hs-definition'>free</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e1}</span><span class='hs-varid'>e1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; x2:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_cup x1 v}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Data.Set.Base.Set [GHC.Types.Char])</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; {VV : (Data.Set.Base.Set [GHC.Types.Char]) | VV == free x1}</span><span class='hs-varid'>free</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e2}</span><span class='hs-varid'>e2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; x2:(Data.Set.Base.Set [GHC.Types.Char])
-&gt; {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_dif x1 v}</span><span class='hs-varop'>`difference`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:[GHC.Types.Char]
-&gt; {v : (Data.Set.Base.Set [GHC.Types.Char]) | v == Set_sng x1}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p> with respect to an environment <code>G</code> if all the <em>free</em> variables in the expression appear in <code>G</code>, i.e. the environment contains bindings for all the variables in the expression that are <em>not</em> bound within the expression. As we've seen repeatedly, often a whole pile of informal handwaving, can be succinctly captured by a type definition that says the <code>free</code> variables in the <code>Expr</code> must be contained in the <code>keys</code> of the environment <code>G</code>:</p>
<pre><span class=hs-linenum>269: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>ClosedExpr</span> <span class='hs-conid'>G</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Subset</span> <span class='hs-layout'>(</span><span class='hs-varid'>free</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>keys</span> <span class='hs-conid'>G</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p> never goes wrong, i.e. we can ensure that <code>eval</code> will not crash with unbound variables, as long as it is invoked with suitable environments:</p>
<pre><span class=hs-linenum>277: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>eval</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>g</span><span class='hs-conop'>:</span><span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClosedExpr</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>We can be sure an <code>Expr</code> is well-scoped if it has <em>no</em> free variables.Lets use that to write a &quot;top-level&quot; evaluator:</p>
<pre><span class=hs-linenum>284: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>topEval</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Expr</span> <span class='hs-keyword'>| Empty (free v)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>285: </span><a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | Set_emp free v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-definition'>topEval</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; {v : AssocativeMap.Expr | Set_sub free v keys x1}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | false}) | Set_emp keys v}</span><span class='hs-varid'>emp</span></a> 
</pre>
<p>Complete the definition of the below function which <em>checks</em> if an <code>Expr</code> is well formed before <code>eval</code>uating it:</p>
<pre><span class=hs-linenum>292: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>evalAny</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Val</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>293: </span><a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; AssocativeMap.Expr
-&gt; (Data.Maybe.Maybe {v : AssocativeMap.Expr | val v})</span><span class='hs-definition'>evalAny</span></a> <a class=annot href="#"><span class=annottext>(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>AssocativeMap.Expr</span><span class='hs-varid'>e</span></a>
<span class=hs-linenum>294: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | false}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : AssocativeMap.Expr | false}
-&gt; {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | isJust v &lt;=&gt; true &amp;&amp; fromJust v == x1}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>({v : AssocativeMap.Expr | false}
 -&gt; {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | false})
-&gt; {v : AssocativeMap.Expr | false}
-&gt; {v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | false}</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>x1:(AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v})
-&gt; {v : AssocativeMap.Expr | Set_sub free v keys x1}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>eval</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map [GHC.Types.Char] {v : AssocativeMap.Expr | val v}) | v == g}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | v == e}</span><span class='hs-varid'>e</span></a>
<span class=hs-linenum>295: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Data.Maybe.Maybe {v : AssocativeMap.Expr | false}) | isJust v &lt;=&gt; false}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>296: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>297: </span>    <a class=annot href="#"><span class=annottext>forall a. {VV : a | false}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>undefined</span></a>  
</pre>
<p>Proof is all well and good, in the end, you need a few sanity tests to kick the tires. So:</p>
<pre><span class=hs-linenum>304: </span><a class=annot href="#"><span class=annottext>[AssocativeMap.Expr]</span><span class='hs-definition'>tests</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [AssocativeMap.Expr] | null v &lt;=&gt; false &amp;&amp; xListSelector v == v2 &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &amp;&amp; v == v1}</span><span class='hs-varid'>v1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &amp;&amp; v == v2}</span><span class='hs-varid'>v2</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>305: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>306: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>v1</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | Set_emp free v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>topEval</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; v == e1}</span><span class='hs-varid'>e1</span></a></span>          <span class='hs-comment'>-- Rejected by LH</span>
<span class=hs-linenum>307: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>v2</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | Set_emp free v}
-&gt; {v : AssocativeMap.Expr | val v}</span><span class='hs-varid'>topEval</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; v == e2 &amp;&amp; free v == Set_cup free c10 Set_dif free e1 Set_sng x}</span><span class='hs-varid'>e2</span></a>          <span class='hs-comment'>-- Accepted by LH</span>
<span class=hs-linenum>308: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; false}</span><span class='hs-varid'>e1</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:[GHC.Types.Char]
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; free v == Set_sng x1}</span><span class='hs-conid'>Var</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | null v &lt;=&gt; false &amp;&amp; v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:AssocativeMap.Expr
-&gt; x2:AssocativeMap.Expr
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; free v == Set_cup free x1 free x2}</span><span class='hs-varop'>`Plus`</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; v == c1 &amp;&amp; free v == Set_empty 0}</span><span class='hs-varid'>c1</span></a> 
<span class=hs-linenum>309: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; free v == Set_cup free c10 Set_dif free e1 Set_sng x}</span><span class='hs-varid'>e2</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[GHC.Types.Char]
-&gt; x2:AssocativeMap.Expr
-&gt; x3:AssocativeMap.Expr
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; free v == Set_cup free x2 Set_dif free v Set_sng x1}</span><span class='hs-conid'>Let</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | null v &lt;=&gt; false &amp;&amp; v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; v == c10 &amp;&amp; free v == Set_empty 0}</span><span class='hs-varid'>c10</span></a> <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; false &amp;&amp; v == e1}</span><span class='hs-varid'>e1</span></a> 
<span class=hs-linenum>310: </span>    <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | null v &lt;=&gt; false}</span><span class='hs-varid'>x</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | null v &lt;=&gt; false}</span><span class='hs-str'>"x"</span></a>
<span class=hs-linenum>311: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; free v == Set_empty 0}</span><span class='hs-varid'>c1</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; free v == Set_empty 0}</span><span class='hs-conid'>Const</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>312: </span>    <a class=annot href="#"><span class=annottext>{v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; free v == Set_empty 0}</span><span class='hs-varid'>c10</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int
-&gt; {v : AssocativeMap.Expr | val v &lt;=&gt; true &amp;&amp; free v == Set_empty 0}</span><span class='hs-conid'>Const</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (10  :  int)}</span><span class='hs-num'>10</span></a>
</pre>
<p> Extend the language above to include functions. That is, extend</p>
<pre><span class=hs-linenum>319: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varop'>...</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Fun</span> <span class='hs-conid'>Var</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>
</pre>
<p>Just focus on ensuring the safety of variable lookups; ensuring full type-safety (i.e. every application is to a function) is rather more complicated and beyond the scope of what we've seen so far.</p>
<h2 id="implementing-maps-binary-search-trees">Implementing Maps: Binary Search Trees</h2>
<p>We just saw how easy it is to <em>use</em> the Associative Map <a href="#mapapi">API</a> to ensure the safety of lookups, even though the <code>Map</code> has a &quot;dynamically&quot; generated set of keys. Next, lets see how we can <em>implement</em> a <code>Map</code> library that respects the API using <a href="#binarysearchtree">Binary Search Trees</a></p>
<p> First, lets provide an implementation of the (hitherto abstract) data type for <code>Map</code>. We shall use Binary Search Trees, wherein, at each <code>Node</code>, the <code>left</code> (resp. <code>right</code>) subtree has keys that are less than (resp. greater than) the root <code>key</code>.</p>
<pre><span class=hs-linenum>346: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <span class='hs-varid'>key</span>   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>347: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>value</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>348: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>left</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>key</span><span class='hs-layout'>}</span> <span class='hs-varid'>v</span>
<span class=hs-linenum>349: </span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>key</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-varid'>v</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>350: </span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Tip</span> 
<span class=hs-linenum>351: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>(#binarysearchtree) that the above refined data definition yields strengthened data constructors that statically ensure that only legal, <em>binary-search ordered</em> trees are created in the program.</p>
<p> Next, we must provide an implementation of the notion of the <code>keys</code> that are defined for a given <code>Map</code>. This is achieved via the (lifted) measure function:</p>
<pre><span class=hs-linenum>365: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>keys</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>366: </span><span class='hs-definition'>keys</span>                <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>367: </span><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:(AssocativeMap.Map a b)
-&gt; {VV : (Data.Set.Base.Set a) | VV == keys x2}</span><span class='hs-definition'>keys</span></a> <span class='hs-conid'>Tip</span>            <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. {v : (Data.Set.Base.Set a) | Set_emp v}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>368: </span><span class='hs-definition'>keys</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set a)
-&gt; x2:(Data.Set.Base.Set a)
-&gt; {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}</span><span class='hs-varid'>union</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:a -&gt; {v : (Data.Set.Base.Set a) | v == Set_sng x1}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set a)
-&gt; x2:(Data.Set.Base.Set a)
-&gt; {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}</span><span class='hs-varid'>union</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:(AssocativeMap.Map a b)
-&gt; {VV : (Data.Set.Base.Set a) | VV == keys x2}</span><span class='hs-varid'>keys</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:(AssocativeMap.Map a b)
-&gt; {VV : (Data.Set.Base.Set a) | VV == keys x2}</span><span class='hs-varid'>keys</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>Armed with the basic type and measure definition, we can start to fill in the operations for <code>Maps</code>.</p>
<p> To make sure you are following, fill in the definition for an <code>emp</code>ty Map:</p>
<pre><span class=hs-linenum>378: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>emp</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{m:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>| NoKey m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>379: </span><a class=annot href="#"><span class=annottext>forall a b. {m : (AssocativeMap.Map a b) | Set_emp keys m}</span><span class='hs-definition'>emp</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. a</span><span class='hs-varid'>undefined</span></a>  
</pre>
<p> To add a key <code>k'</code> to a <code>Map</code> we recursively traverse the <code>Map</code> zigging <code>left</code> or <code>right</code> depending on the result of comparisons with the keys along the path. Unfortunately, the version below has an (all too common!) bug, and hence, is <em>rejected</em> by LiquidHaskell. Find and fix the bug so that the function is verified.</p>
<pre><span class=hs-linenum>391: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>set</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>| PlusKey k m n}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>392: </span><span class=hs-error><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; b
-&gt; x4:(AssocativeMap.Map a b)
-&gt; {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}</span><span class='hs-definition'>set</span></a></span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>v'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>393: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:b
-&gt; x3:(AssocativeMap.Map {VV : a | VV &lt; x1} b)
-&gt; x4:(AssocativeMap.Map {VV : a | x1 &lt; VV} b)
-&gt; {v : (AssocativeMap.Map a b) | keys v == Set_cup Set_sng x1 Set_cup keys x3 keys x4 &amp;&amp; left v == x3 &amp;&amp; right v == x4 &amp;&amp; value v == x2 &amp;&amp; key v == x1}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == v'}</span><span class='hs-varid'>v'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>394: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; v}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; b
-&gt; x4:(AssocativeMap.Map a b)
-&gt; {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == v}</span><span class='hs-varid'>v</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>395: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; b
-&gt; x4:(AssocativeMap.Map a b)
-&gt; {n : (AssocativeMap.Map a b) | keys n == Set_cup Set_sng x2 keys x4}</span><span class='hs-varid'>set</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == v}</span><span class='hs-varid'>v</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>396: </span><span class='hs-definition'>set</span> <span class='hs-varid'>k'</span> <span class='hs-varid'>v'</span> <span class='hs-conid'>Tip</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:b
-&gt; x3:(AssocativeMap.Map {VV : a | VV &lt; x1} b)
-&gt; x4:(AssocativeMap.Map {VV : a | x1 &lt; VV} b)
-&gt; {v : (AssocativeMap.Map a b) | keys v == Set_cup Set_sng x1 Set_cup keys x3 keys x4 &amp;&amp; left v == x3 &amp;&amp; right v == x4 &amp;&amp; value v == x2 &amp;&amp; key v == x1}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == v'}</span><span class='hs-varid'>v'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | false} b) | keys v == Set_empty 0}</span><span class='hs-conid'>Tip</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | false} b) | keys v == Set_empty 0}</span><span class='hs-conid'>Tip</span></a>
</pre>
<p> Next, lets write the <code>mem</code> function that returns the value associated with a key <code>k'</code>. To do so we just compare <code>k'</code> with the root key, if they are equal, we return the binding, and otherwise we go down the <code>left</code> (resp. <code>right</code>) subtree if sought for key is less (resp. greater) than the root <code>key</code>. Crucially, we want to check that lookup <em>never fails</em>, and hence, we implement the <code>Tip</code> (i.e. empty) case with <code>die</code> gets LiquidHaskell to prove that that case is indeed dead code, i.e. never happens at run-time.</p>
<pre><span class=hs-linenum>409: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>get'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>  <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Map k v | HasKey k m}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>410: </span><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-definition'>get'</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{m : (AssocativeMap.Map a b) | Set_mem k' keys m}</span><span class='hs-varid'>m</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>411: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == v}</span><span class='hs-varid'>v</span></a>
<span class=hs-linenum>412: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; v}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-varid'>get'</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a></span>
<span class=hs-linenum>413: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-varid'>get'</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a></span>
<span class=hs-linenum>414: </span><span class='hs-definition'>get'</span>  <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false} -&gt; a</span><span class='hs-varid'>die</span></a>  <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-str'>"Lookup Never Fails"</span></a>
</pre>
<p> the function above is <em>rejected</em> by LiquidHaskell. This is a puzzler (and a bummer!) because in fact it <em>is</em> correct. So what gives? Well, lets look at the error for the call <code>get' k' l</code></p>

<p>LiquidHaskell is <em>unable</em> to deduce that the the key <code>k'</code> definitely belongs in the <code>left</code> subtree <code>l</code>. Well, lets ask ourselves: <em>why</em> must <code>k'</code> belong in the left subtree? From the input, we know <code>HasKey k' m</code> i.e. that <code>k'</code> is <em>somewhere</em> in <code>m</code>. That is <em>one of</em> the following holds:</p>
<ol style="list-style-type: decimal">
<li><code>k' == k</code> or,</li>
<li><code>HasKey k' l</code> or,</li>
<li><code>HasKey k' r</code>.</li>
</ol>
<p>As the preceding guard <code>k' == k</code> fails, we (and LiquidHaskell) can rule out case (1). Now, what about the <code>Map</code> tells us that case (2) must hold, i.e. that case (3) cannot hold? The <em>BST invariant</em>, all keys in <code>r</code> exceed <code>k</code> which itself exceeds <code>k'</code>. That is, all nodes in <code>r</code> are <em>disequal</em> to <code>k'</code> and hence <code>k'</code> cannot be in <code>r</code>, ruling out case (3). Formally, we need the fact that: <br /><span class="math">$$\forall\ \vkey,\ \vt. \vt :: {\vMap\ \reft{\vkey'}{k}{\vkey' \not = \vkey}\ v}
                        \ \Rightarrow\
                        \lnot (\vHasKey\ \vkey\ \vt)$$</span><br /></p>
<p> Unfortunately, LiquidHaskell <em>cannot automatically</em> deduce facts like the above, as they relate refinements of a container's <em>type parameters</em> (here: <span class="math">$\vkey' \not = \vkey$</span>, which refines the <code>Map</code>s first type parameter) with properties of the entire container (here: <span class="math">$\vHasKey\ \vkey\ \vt$</span>).  Fortunately, it is both easy to <em>state</em>, <em>prove</em> and <em>use</em> facts like the above.</p>
<p> To state a lemma, we need only convert it into a <a href="curry-howard">type</a> by viewing universal quantifiers as function parameters, and implications as function types:</p>
<pre><span class=hs-linenum>476: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lemma_notMem</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>key</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-keyword'>{k:</span><span class='hs-definition'>k</span> <span class='hs-keyword'>| k /= key}</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| not (HasKey key m)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>477: </span><a class=annot href="#"><span class=annottext>forall a b.
x1:a
-&gt; x2:(AssocativeMap.Map {VV : a | VV /= x1} b)
-&gt; {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}</span><span class='hs-definition'>lemma_notMem</span></a> <span class='hs-keyword'>_</span>   <span class='hs-conid'>Tip</span>            <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a> 
<span class=hs-linenum>478: </span><span class='hs-definition'>lemma_notMem</span> <span class='hs-varid'>key</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
x1:a
-&gt; x2:(AssocativeMap.Map {VV : a | VV /= x1} b)
-&gt; {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>key</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map a b) | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Bool
-&gt; x2:GHC.Types.Bool
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1 &amp;&amp; Prop v}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>forall a b.
x1:a
-&gt; x2:(AssocativeMap.Map {VV : a | VV /= x1} b)
-&gt; {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>key</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map a b) | v == r}</span><span class='hs-varid'>r</span></a> 
</pre>
<p> Note how the signature for <code>lemma_notMem</code> corresponds exactly to the missing fact from above. The &quot;output&quot; type is a <code>Bool</code> refined with the proposition that we desire. We <em>prove</em> the lemma simply by <em>traversing</em> the tree which lets LiquidHaskell build up a proof for the output fact by inductively combining the proofs from the subtrees.</p>
<p> To use a lemma, we need to <em>instantiate</em> it to the particular keys and trees we care about, by &quot;calling&quot; the lemma function, and forcing its result to be in the <em>environment</em> used to typecheck the expression where we want to use the lemma. Say what? Here is a verified <code>get</code>:</p>
<pre><span class=hs-linenum>495: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>get</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Map k v | HasKey k m}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>496: </span><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-definition'>get</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>k'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>497: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == v}</span><span class='hs-varid'>v</span></a>
<span class=hs-linenum>498: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; v}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool -&gt; a -&gt; a</span><span class='hs-varid'>assert</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a b.
x1:a
-&gt; x2:(AssocativeMap.Map {VV : a | VV /= x1} b)
-&gt; {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(a -&gt; a) -&gt; a -&gt; a</span><span class='hs-varop'>$</span></a>
<span class=hs-linenum>499: </span>                  <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>500: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool -&gt; a -&gt; a</span><span class='hs-varid'>assert</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a b.
x1:a
-&gt; x2:(AssocativeMap.Map {VV : a | VV /= x1} b)
-&gt; {v : GHC.Types.Bool | not (Set_mem x1 keys x2)}</span><span class='hs-varid'>lemma_notMem</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(a -&gt; a) -&gt; a -&gt; a</span><span class='hs-varop'>$</span></a>
<span class=hs-linenum>501: </span>                  <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a -&gt; {m : (AssocativeMap.Map a b) | Set_mem x2 keys m} -&gt; b</span><span class='hs-varid'>get</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>502: </span><span class='hs-definition'>get</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false} -&gt; a</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-str'>"Lookup failed? Impossible."</span></a>
</pre>
<p>By calling <code>lemma_notMem</code> we create a dummy <code>Bool</code> that carries the desired refinement that tells LiquidHaskell that <code>not (HasKey k' r)</code> (resp. <code>not (HasKey k' l)</code>). We force the calls to <code>get k' l</code> (resp. <code>get k' r</code>) to be typechecked using the materialized refinement by wrapping the calls within a function <code>assert</code></p>
<pre><span class=hs-linenum>511: </span><a class=annot href="#"><span class=annottext>forall a b. a -&gt; b -&gt; b</span><span class='hs-definition'>assert</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>
</pre>
<p> This technique of materializing auxiliary facts via <em>ghost values</em> is a well known idea in the program verification literature. Usually, one has to take care to ensure that ghost computations do not interfere with the regular computations. If we had to actually <em>execute</em> <code>lemma_notMem</code> it would totally wreck the efficient logarithmic lookup times  as we'd traverse the entire tree all the time </p>
<p> comes to our rescue: as the ghost value is (trivially) not needed, it is never computed. In fact, it is straightforward to entirely <em>erase</em> the call in the compiled code, which lets us freely <code>assert</code> such <code>lemma</code>s to carry out proofs, without paying any runtime penalty. In an eager language we would have to do a bit of work to specifically mark the computation as a ghost or <a href="proof-irrelevance">irrelevant</a> but in the lazy setting we get this for free.</p>
<p> Capisce? Fix the definition of <code>mem</code> so that it verifiably implements the given signature:</p>
<pre><span class=hs-linenum>537: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| Prop v &lt;=&gt; HasKey k m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>538: </span><span class=hs-error><a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; x3:(AssocativeMap.Map a b)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem x2 keys x3}</span><span class='hs-definition'>mem</span></a></span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>k'</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>k</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class=hs-linenum>539: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>540: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; v}</span><span class='hs-varop'>&lt;</span></a>  <a class=annot href="#"><span class=annottext>{VV : a | VV == k}</span><span class='hs-varid'>k</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; x3:(AssocativeMap.Map a b)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem x2 keys x3}</span><span class='hs-varid'>mem</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | VV &lt; k} b) | v == l}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>541: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b.
(GHC.Classes.Ord a) =&gt;
x2:a
-&gt; x3:(AssocativeMap.Map a b)
-&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Set_mem x2 keys x3}</span><span class='hs-varid'>mem</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == k'}</span><span class='hs-varid'>k'</span></a> <a class=annot href="#"><span class=annottext>{v : (AssocativeMap.Map {VV : a | k &lt; VV} b) | v == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>542: </span><span class='hs-definition'>mem</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Tip</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
</pre>
<p> To make sure you really understand this business of ghosts values and proofs, complete the implementation of the following function which returns a <code>fresh</code> integer that is <em>distinct</em> from all the values in its input list:</p>
<pre><span class=hs-linenum>550: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| not (Elem v xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>551: </span><a class=annot href="#"><span class=annottext>x1:[GHC.Types.Int]
-&gt; {v : GHC.Types.Int | not (Set_mem v elems x1)}</span><span class='hs-definition'>fresh</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. a</span><span class='hs-varid'>undefined</span></a>
</pre>
<p>To refresh your memory, here are the definitions for <code>Elem</code> we <a href="#listelems">saw earlier</a></p>
<pre><span class=hs-linenum>558: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Elem</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set_mem</span> <span class='hs-conid'>X</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span> <span class='hs-conid'>Ys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>559: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>elems</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>560: </span><a class=annot href="#"><span class=annottext>forall a.
(GHC.Classes.Ord a) =&gt;
x2:[a] -&gt; {VV : (Data.Set.Base.Set a) | VV == elems x2}</span><span class='hs-definition'>elems</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. {v : (Data.Set.Base.Set a) | Set_emp v}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum>561: </span><span class='hs-definition'>elems</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:a -&gt; {v : (Data.Set.Base.Set a) | v == Set_sng x1}</span><span class='hs-varid'>singleton</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Base.Set a)
-&gt; x2:(Data.Set.Base.Set a)
-&gt; {v : (Data.Set.Base.Set a) | v == Set_cup x1 v}</span><span class='hs-varop'>`union`</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a.
(GHC.Classes.Ord a) =&gt;
x2:[a] -&gt; {VV : (Data.Set.Base.Set a) | VV == elems x2}</span><span class='hs-varid'>elems</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
<h2 id="recap">Recap</h2>
<p>In this chapter we saw how to combine several of the techniques from previous chapters in a case study. We learnt how to:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Define</strong> an API for associative maps that used refinements to track the <em>set</em> of <code>keys</code> stored in a map, in order to prevent lookup failures, the <code>NullPointerDereference</code> errors of the functional world,</p></li>
<li><p><strong>Use</strong> the API to implement a small interpreter that is guaranteed to never fail with <code>UnboundVariable</code> errors, as long as the input expressions were closed,</p></li>
<li><p><strong>Implement</strong> the API using Binary Search Trees; in particular, using <em>ghost lemmas</em> to <code>assert</code> facts that LiquidHaskell is otherwise unable to deduce automatically.</p></li>
</ol>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<h1 id="boolmeasures">Boolean Measures</h1>
<p>In the last two chapters, we saw how refinements could be used to reason about the properties of basic <code>Int</code> values like vector indices, or the elements of a list. Next, lets see how we can describe properties of aggregate structures like lists and trees, and use these properties to improve the APIs for operating over such structures.</p>

<h2 id="partial-functions">Partial Functions</h2>
<p>As a motivating example, let us return to problem of ensuring the safety of division. Recall that we wrote:</p>
<pre><span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>divide</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonZero</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-definition'>divide</span></a> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; Int</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"divide-by-zero"</span></a>
<span class=hs-linenum>49: </span><span class='hs-definition'>divide</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int
-&gt; x2:{v : Int | v /= 0}
-&gt; {v : Int | x1 &gt;= 0 &amp;&amp; x2 &gt;= 0 =&gt; v &gt;= 0 &amp;&amp; x1 &gt;= 0 &amp;&amp; x2 &gt;= 1 =&gt; v &lt;= x1 &amp;&amp; v == x1 / x2}</span><span class='hs-varop'>`div`</span></a> <a class=annot href="#"><span class=annottext>{v : Int | 0 /= v}</span><span class='hs-varid'>n</span></a>
</pre>
<p> asserted by the input type <code>NonZero</code> allows LiquidHaskell to prove that the <code>die</code> is <em>never</em> executed at run-time, but consequently, requires us to establish that wherever <code>divide</code> is <em>used</em>, the second parameter be provably non-zero. This is requirement is not onerous when we know exactly what the divisor is <em>statically</em></p>
<pre><span class=hs-linenum>60: </span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; Int</span><span class='hs-definition'>avg2</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>y</span></a><span class='hs-layout'>)</span>     <a class=annot href="#"><span class=annottext>{v : Int | v == (2  :  int)}</span><span class='hs-num'>2</span></a>
<span class=hs-linenum>61: </span>
<span class=hs-linenum>62: </span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; Int -&gt; Int</span><span class='hs-definition'>avg3</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>z</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == z}</span><span class='hs-varid'>z</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Int | v == (3  :  int)}</span><span class='hs-num'>3</span></a>
</pre>
<p>However, it can be more of a challenge when the divisor is obtained <em>dynamically</em>. For example, lets write a function to find the number of elements in a list</p>
<pre><span class=hs-linenum>70: </span><span class='hs-definition'>size</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>71: </span><a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>x1:Int# -&gt; {v : Int | v == (x1  :  int)}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>72: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>and use it to compute the average value of a list:</p>
<pre><span class=hs-linenum>78: </span><a class=annot href="#"><span class=annottext>[Int] -&gt; Int</span><span class='hs-definition'>avgMany</span></a> <a class=annot href="#"><span class=annottext>[Int]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == total}</span><span class='hs-varid'>total</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v == elems &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a></span> 
<span class=hs-linenum>79: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>80: </span>    <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v} -&gt; Int</span><span class='hs-varid'>sum</span></a>  <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [Int] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
<span class=hs-linenum>81: </span>    <a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [Int] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>Uh oh. LiquidHaskell wags its finger at us!</p>

<p> that the divisor is <code>NonZero</code>, because it <em>can be</em> <code>0</code> -- when the list is <em>empty</em>. Thus, we need a way of specifying that the input to <code>avgMany</code> is indeed non-empty!</p>
<h2 id="usingmeasures">Lifting Functions to Measures</h2>
<p> shall we tell LiquidHaskell that a list is <em>non-empty</em>? Recall the notion of <code>measure</code> previously <a href="#vectorbounds">introduced</a> to describe the size of a <code>Data.Vector</code>. In that spirit, lets write a function that computes whether a list is not empty:</p>
<pre><span class=hs-linenum>113: </span><span class='hs-definition'>notEmpty</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> 
<span class=hs-linenum>114: </span><a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {VV : Bool | Prop VV &lt;=&gt; notEmpty x1}</span><span class='hs-definition'>notEmpty</span></a> <span class='hs-conid'>[]</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum>115: </span><span class='hs-definition'>notEmpty</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a> 
</pre>
<p> is a <em>total</em> Haskell function,</p>
<ol style="list-style-type: decimal">
<li>With a <em>single</em> equation per data constructor, and</li>
<li>Guaranteed to <em>terminate</em>, typically via structural recursion.</li>
</ol>
<p>We can tell LiquidHaskell to <em>lift</em> a function meeting the above requirements into the refinement logic by declaring:</p>
<pre><span class=hs-linenum>128: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>notEmpty</span> <span class='hs-keyword'>@-}</span>
</pre>
<p> To use the newly defined measure, we define an alias for non-empty lists, i.e. the <em>subset</em> of plain old Haskell lists <code>[a]</code> for which the predicate <code>notEmpty</code> holds</p>
<pre><span class=hs-linenum>139: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>notEmpty</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>We can now refine various signatures to establish the safety of the list-average function.</p>
<p> First, we specify that <code>size</code> returns a non-zero value when the input list is not-empty:</p>
<pre><span class=hs-linenum>150: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p> Second, we specify that the <code>average</code> is only sensible for non-empty lists:</p>
<pre><span class=hs-linenum>157: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>average</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>158: </span><a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v} -&gt; Int</span><span class='hs-definition'>average</span></a> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v}</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == total}</span><span class='hs-varid'>total</span></a> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v == elems &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>159: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>160: </span>    <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v} -&gt; Int</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v &amp;&amp; v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>161: </span>    <a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v &amp;&amp; v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>Fix the code below to obtain an alternate variant <code>average'</code> that returns <code>Nothing</code> for empty lists:</p>
<pre><span class=hs-linenum>168: </span><span class='hs-definition'>average'</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>169: </span><a class=annot href="#"><span class=annottext>[Int] -&gt; (Maybe Int)</span><span class='hs-definition'>average'</span></a> <a class=annot href="#"><span class=annottext>[Int]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>170: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | Prop v &amp;&amp; v == GHC.Types.True &amp;&amp; v == ok}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; {v : (Maybe Int) | isJust v &lt;=&gt; true &amp;&amp; fromJust v == x1}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>(Int -&gt; (Maybe Int)) -&gt; Int -&gt; (Maybe Int)</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v == total}</span><span class='hs-varid'>total</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v == elems &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a></span> 
<span class=hs-linenum>171: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Maybe Int) | isJust v &lt;=&gt; false}</span><span class='hs-conid'>Nothing</span></a> 
<span class=hs-linenum>172: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>173: </span>    <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>total</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Int] | notEmpty v} -&gt; Int</span><span class='hs-varid'>sum</span></a>  <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [Int] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
<span class=hs-linenum>174: </span>    <a class=annot href="#"><span class=annottext>{v : Int | notEmpty xs =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [Int] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>175: </span>    <a class=annot href="#"><span class=annottext>{v : Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-varid'>ok</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a>    <span class='hs-comment'>-- What expression goes here? </span>
</pre>
<p>An important aspect of formal verifiers like LiquidHaskell is that they help establish properties not just of your <em>implementations</em> but equally, or more importantly, of your <em>specifications</em>. In that spirit, can you explain why the following two variants of <code>size</code> are <em>rejected</em> by LiquidHaskell?</p>
<pre><span class=hs-linenum>186: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size1</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pos</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>187: </span><a class=annot href="#"><span class=annottext>forall a. {v : [a] | notEmpty v} -&gt; {v : Int | 0 &lt; v}</span><span class='hs-definition'>size1</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>x1:Int# -&gt; {v : Int | v == (x1  :  int)}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>188: </span><span class='hs-definition'>size1</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>forall a. {v : [a] | notEmpty v} -&gt; {v : Int | 0 &lt; v}</span><span class='hs-varid'>size1</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
<span class=hs-linenum>189: </span>
<span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size2</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>191: </span><a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0}</span><span class='hs-definition'>size2</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>x1:Int# -&gt; {v : Int | v == (x1  :  int)}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>192: </span><span class='hs-definition'>size2</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <span class=hs-error><a class=annot href="#"><span class=annottext>{v : Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {v : Int | notEmpty x1 =&gt; v &gt; 0}</span><span class='hs-varid'>size2</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
</pre>
<p> <strong>solution</strong></p>
<h2 id="a-safe-list-api">A Safe List API</h2>
<p>Now that we can talk about non-empty lists, we can ensure the safety of various list-manipulating functions which are only well-defined on non-empty lists and which crash with unexpected run-time errors otherwise.</p>
<p> For example, we can type the potentially dangerous <code>head</code> and <code>tail</code> as:</p>
<pre><span class=hs-linenum>210: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>head</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>211: </span><a class=annot href="#"><span class=annottext>forall a. {v : [a] | notEmpty v} -&gt; a</span><span class='hs-definition'>head</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>212: </span><span class='hs-definition'>head</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; a</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"Fear not! 'twill ne'er come to pass"</span></a>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>tail</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>215: </span><a class=annot href="#"><span class=annottext>forall a. {v : [a] | notEmpty v} -&gt; [a]</span><span class='hs-definition'>tail</span></a> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>216: </span><span class='hs-definition'>tail</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; [a]</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"Relaxeth! this too shall ne'er be"</span></a>
</pre>
<p>LiquidHaskell deduces that the second equations are <em>dead code</em> thanks to the precondition, which ensures callers only supply non-empty arguments.</p>
<p>Write down a specification for <code>null</code> such that <code>safeHead</code> is verified:</p>
<pre><span class=hs-linenum>226: </span><span class='hs-definition'>safeHead</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>227: </span><a class=annot href="#"><span class=annottext>forall a. [a] -&gt; (Maybe a)</span><span class='hs-definition'>safeHead</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>228: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>[a] -&gt; Bool</span><span class='hs-varid'>null</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. {v : (Maybe a) | isJust v &lt;=&gt; false}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>229: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; {v : (Maybe a) | isJust v &lt;=&gt; true &amp;&amp; fromJust v == x1}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>(a -&gt; (Maybe a)) -&gt; a -&gt; (Maybe a)</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v} -&gt; a</span><span class='hs-varid'>head</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>  
<span class=hs-linenum>230: </span>
<span class=hs-linenum>231: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>null</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>232: </span><a class=annot href="#"><span class=annottext>forall a. [a] -&gt; Bool</span><span class='hs-definition'>null</span></a> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | Prop v &amp;&amp; v == GHC.Types.True}</span><span class='hs-conid'>True</span></a> 
<span class=hs-linenum>233: </span><span class='hs-definition'>null</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | not (Prop v) &amp;&amp; v == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
</pre>
<p> Lets use the above to write a function that chunks sequences into non-empty groups of equal elements:</p>
<pre><span class=hs-linenum>241: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>groupEq</span>         <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>242: </span><a class=annot href="#"><span class=annottext>forall a. (Eq a) =&gt; [a] -&gt; [{v : [a] | notEmpty v}]</span><span class='hs-definition'>groupEq</span></a> <span class='hs-conid'>[]</span>          <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a &lt;p :: a a -&gt; Prop&gt;.
{v : [a]&lt;\x5 VV -&gt; p x5&gt; | notEmpty v &lt;=&gt; false &amp;&amp; null v &lt;=&gt; true &amp;&amp; len v == 0}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>243: </span><span class='hs-definition'>groupEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:[a]
-&gt; {v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == ys &amp;&amp; v == ys &amp;&amp; len v == len ys &amp;&amp; len v &gt;= 0 &amp;&amp; len v &lt;= len xs}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:{v : [a] | notEmpty v}
-&gt; x2:[{v : [a] | notEmpty v}]&lt;\_ VV -&gt; notEmpty v&gt;
-&gt; {v : [{v : [a] | notEmpty v}]&lt;\_ VV -&gt; notEmpty v&gt; | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>forall a. (Eq a) =&gt; [a] -&gt; [{v : [a] | notEmpty v}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == zs &amp;&amp; v == zs &amp;&amp; len v == len zs &amp;&amp; len v &gt;= 0 &amp;&amp; len v &lt;= len xs}</span><span class='hs-varid'>zs</span></a>
<span class=hs-linenum>244: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>245: </span>    <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : [a] | VV == ys &amp;&amp; len VV == len ys &amp;&amp; len VV &gt;= 0 &amp;&amp; len VV &lt;= len xs}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : [a] | VV == zs &amp;&amp; len VV == len zs &amp;&amp; len VV &gt;= 0 &amp;&amp; len VV &lt;= len xs}</span><span class='hs-varid'>zs</span></a><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(a -&gt; Bool)
-&gt; x3:[a]
-&gt; ({v : [a] | len v &lt;= len x3}, {v : [a] | len v &lt;= len x3})</span><span class='hs-varid'>span</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>By using the fact that <em>each element</em> in the output returned by <code>groupEq</code> is in fact of the form <code>x:ys</code>, LiquidHaskell infers that <code>groupEq</code> returns a <code>[NEList a]</code> that is, a list of <em>non-empty lists</em>.</p>
<p>We can use <code>groupEq</code> to write a function that eliminates stuttering from a String:</p>
<pre><span class=hs-linenum>257: </span><span class='hs-comment'>-- &gt;&gt;&gt; eliminateStutter "ssstringssss liiiiiike thisss"</span>
<span class=hs-linenum>258: </span><span class='hs-comment'>-- "strings like this"</span>
<span class=hs-linenum>259: </span><a class=annot href="#"><span class=annottext>forall a. (Eq a) =&gt; [a] -&gt; [a]</span><span class='hs-definition'>eliminateStutter</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v} -&gt; a</span><span class='hs-varid'>head</span></a> <a class=annot href="#"><span class=annottext>({v : [{v : [a] | notEmpty v}] | len v &gt;= 0} -&gt; [a])
-&gt; {v : [{v : [a] | notEmpty v}] | len v &gt;= 0} -&gt; [a]</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>forall a. (Eq a) =&gt; [a] -&gt; [{v : [a] | notEmpty v}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>LiquidHaskell automatically instantiates the type parameter for <code>map</code> in <code>eliminateStutter</code> to <code>notEmpty v</code> to deduce that <code>head</code> is only called on non-empty lists.</p>
<p> One of my favorite folds is <code>foldr1</code> which uses the first element of the sequence as the initial value. Of course, it should only be called with non-empty sequences!</p>
<pre><span class=hs-linenum>272: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>foldr1</span>      <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>273: </span><a class=annot href="#"><span class=annottext>forall a. (a -&gt; a -&gt; a) -&gt; {v : [a] | notEmpty v} -&gt; a</span><span class='hs-definition'>foldr1</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>274: </span><span class='hs-definition'>foldr1</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; a</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"foldr1"</span></a> 
<span class=hs-linenum>275: </span>
<span class=hs-linenum>276: </span><span class='hs-definition'>foldr</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> 
<span class=hs-linenum>277: </span><a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><span class='hs-definition'>foldr</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>acc</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == acc}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum>278: </span><span class='hs-definition'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; b -&gt; b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b -&gt; b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == acc}</span><span class='hs-varid'>acc</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
<p> Thanks to the precondition, LiquidHaskell will prove that the <code>die</code> code is indeed dead. Thus, we can write</p>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>287: </span><a class=annot href="#"><span class=annottext>forall a. (Num a) =&gt; {v : [a] | notEmpty v} -&gt; a</span><span class='hs-definition'>sum</span></a> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; a</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"cannot add up empty list"</span></a>
<span class=hs-linenum>288: </span><span class='hs-definition'>sum</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(a -&gt; a -&gt; a) -&gt; {v : [a] | notEmpty v} -&gt; a</span><span class='hs-varid'>foldr1</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {VV : a | VV == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>Consequently, we can only invoke <code>sum</code> on non-empty lists, so:</p>
<pre><span class=hs-linenum>294: </span><a class=annot href="#"><span class=annottext>Integer</span><span class='hs-definition'>sumOk</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Integer] | notEmpty v} -&gt; Integer</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{v : [Integer] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>2</span><span class='hs-layout'>,</span><span class='hs-num'>3</span><span class='hs-layout'>,</span><span class='hs-num'>4</span><span class='hs-layout'>,</span><span class='hs-num'>5</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- accepted by LH</span>
<span class=hs-linenum>295: </span>
<span class=hs-linenum>296: </span><a class=annot href="#"><span class=annottext>Integer</span><span class='hs-definition'>sumBad</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Integer] | notEmpty v} -&gt; Integer</span><span class='hs-varid'>sum</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [Integer] | notEmpty v &lt;=&gt; false &amp;&amp; null v &lt;=&gt; true &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class='hs-conid'>[]</span></a></span>             <span class='hs-comment'>-- rejected by LH</span>
</pre>
<p>The function below computes a weighted average of its input. Unfortunately, LiquidHaskell is not very happy about it. Can you figure out why, and fix the code or specification appropriately?</p>
<pre><span class=hs-linenum>304: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>wtAverage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>305: </span><a class=annot href="#"><span class=annottext>{v : [({v : Int | 0 &lt; v}, {v : Int | 0 &lt; v})] | notEmpty v} -&gt; Int</span><span class='hs-definition'>wtAverage</span></a> <a class=annot href="#"><span class=annottext>{v : [({v : Int | 0 &lt; v}, {v : Int | 0 &lt; v})] | notEmpty v}</span><span class='hs-varid'>wxs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Int -&gt; {v : Int | 0 /= v} -&gt; Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v == totElems &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totElems</span></a> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v == totWeight &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totWeight</span></a> 
<span class=hs-linenum>306: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>307: </span>    <a class=annot href="#"><span class=annottext>[{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}]</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><span class='hs-varid'>map</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>({v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}, {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v})
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-keyglyph'>\</span></a><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v == w &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>w</span></a> <a class=annot href="#"><span class=annottext>x1:Int
-&gt; x2:Int
-&gt; {v : Int | x1 &gt; 0 &amp;&amp; x2 &gt; 0 =&gt; v &gt;= x1 &amp;&amp; v &gt;= x2 &amp;&amp; x1 &gt; 1 &amp;&amp; x2 &gt; 1 =&gt; v &gt; x1 &amp;&amp; v &gt; x2 &amp;&amp; x1 == 0 || x2 == 0 =&gt; v == 0}</span><span class='hs-varop'>*</span></a> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v == x &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [({v : Int | 0 &lt; v}, {v : Int | 0 &lt; v})] | notEmpty v &amp;&amp; v == wxs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>308: </span>    <a class=annot href="#"><span class=annottext>[{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}]</span><span class='hs-varid'>weights</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><span class='hs-varid'>map</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:({v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}, {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v})
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v == fst x1 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-keyglyph'>\</span></a><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v == w &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>w</span></a>    <span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [({v : Int | 0 &lt; v}, {v : Int | 0 &lt; v})] | notEmpty v &amp;&amp; v == wxs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>309: </span>    <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totElems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | notEmpty v}
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; notEmpty weights =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | v == elems &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>elems</span></a></span> 
<span class=hs-linenum>310: </span>    <a class=annot href="#"><span class=annottext>{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totWeight</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | notEmpty v}
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | v == weights &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>weights</span></a></span> 
<span class=hs-linenum>311: </span>    <a class=annot href="#"><span class=annottext>{v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | notEmpty v}
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}
 -&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}
 -&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v})
-&gt; {v : [{v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}] | notEmpty v}
-&gt; {v : Int | notEmpty wxs =&gt; v &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>foldr1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + v}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<span class=hs-linenum>312: </span>
<span class=hs-linenum>313: </span><span class='hs-definition'>map</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>314: </span><a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><span class='hs-definition'>map</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a &lt;p :: a a -&gt; Prop&gt;.
{v : [a]&lt;\x5 VV -&gt; p x5&gt; | notEmpty v &lt;=&gt; false &amp;&amp; null v &lt;=&gt; true &amp;&amp; len v == 0}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>315: </span><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:[a]
-&gt; {v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a> 
</pre>
<p>On what variables are the errors? How are those variables' values computed? Can you think of a better specification for the function(s) doing those computations?</p>
<p>Non-empty lists pop up in many places, and it is rather convenient to have the type system track non-emptiness without having to make up special types. Consider the <code>risers</code> function: </p>
<pre><span class=hs-linenum>329: </span><span class='hs-definition'>risers</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>330: </span><a class=annot href="#"><span class=annottext>forall a. (Ord a) =&gt; [a] -&gt; [[a]]</span><span class='hs-definition'>risers</span></a> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a &lt;p :: a a -&gt; Prop&gt;.
{v : [a]&lt;\x5 VV -&gt; p x5&gt; | notEmpty v &lt;=&gt; false &amp;&amp; null v &lt;=&gt; true &amp;&amp; len v == 0}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>331: </span><span class='hs-definition'>risers</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | notEmpty v &lt;=&gt; false &amp;&amp; null v &lt;=&gt; true &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>332: </span><span class='hs-definition'>risers</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>etc</span><span class='hs-layout'>)</span>
<span class=hs-linenum>333: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | Prop v &lt;=&gt; x1 &lt;= v}</span><span class='hs-varop'>&lt;=</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:[a]
-&gt; {v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == s &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:[a]
-&gt; x2:[[a]]
-&gt; {v : [[a]] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>{v : [[a]] | v == ss &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ss</span></a>
<span class=hs-linenum>334: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span> <a class=annot href="#"><span class=annottext>x1:[a]
-&gt; x2:[[a]]
-&gt; {v : [[a]] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [a] | v == s &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>x1:[a]
-&gt; x2:[[a]]
-&gt; {v : [[a]] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>{v : [[a]] | v == ss &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>335: </span>    <span class='hs-keyword'>where</span> 
<span class=hs-linenum>336: </span>      <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>s</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>[[a]]</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [[a]] | notEmpty v} -&gt; ([a], [[a]])</span><span class='hs-varid'>safeSplit</span></a></span> <a class=annot href="#"><span class=annottext>({v : [[a]] | len v &gt;= 0} -&gt; ([a], [[a]]))
-&gt; {v : [[a]] | len v &gt;= 0} -&gt; ([a], [[a]])</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>forall a. (Ord a) =&gt; [a] -&gt; [[a]]</span><span class='hs-varid'>risers</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:[a]
-&gt; {v : [a] | notEmpty v &lt;=&gt; true &amp;&amp; null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; len v == 1 + len x2 &amp;&amp; xsListSelector v == x2}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == etc &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>etc</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>337: </span>
<span class=hs-linenum>338: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeSplit</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>339: </span><a class=annot href="#"><span class=annottext>forall a. {v : [a] | notEmpty v} -&gt; (a, [a])</span><span class='hs-definition'>safeSplit</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b &lt;p2 :: a b -&gt; Prop&gt;.
x1:a
-&gt; x2:{VV : b&lt;p2 x1&gt; | true}
-&gt; {v : (a, b)&lt;\x6 VV -&gt; p2 x6&gt; | fst v == x1 &amp;&amp; x_Tuple22 v == x2 &amp;&amp; snd v == x2 &amp;&amp; x_Tuple21 v == x1}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>340: </span><span class='hs-definition'>safeSplit</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [Char] | false} -&gt; (a, [a])</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{v : [Char] | len v &gt;= 0}</span><span class='hs-str'>"don't worry, be happy"</span></a>
</pre>
<p>The call to <code>safeSplit</code> requires its input be non-empty, and LiquidHaskell does not believe that the call inside <code>risers</code> meets this requirement. Can you devise a specification for <code>risers</code> that allows LiquidHaskell to verify the call to <code>safeSplit</code> that <code>risers</code> will not <code>die</code>?</p>
<h2 id="recap">Recap</h2>
<p>In this chapter we saw how LiquidHaskell lets you</p>
<ol style="list-style-type: decimal">
<li><p>Define <em>structural properties</em> of data types,</p></li>
<li><p>Use refinements over these properties to describe key invariants that establish, at compile-time, the safety of operations that might otherwise fail on unexpected values at run-time, all while,</p></li>
<li><p>Working with plain Haskell types, here, Lists, without having to [make up new types][apple-riser] which can have the unfortunate effect of adding a multitude of constructors and conversions which often clutter implementations and specifications.</p></li>
</ol>
<p>Of course, We can do a lot more with measures, so lets press on!</p>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

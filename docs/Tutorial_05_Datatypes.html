<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> collapsibleDiv {</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.3.</b> Refinement Types</a></li>
</ul>
<li><a href='Tutorial_02_Logic.html'><b>2.</b>Logic &amp; SMT</a></li>
<ul class='section'>
<li><a href='Tutorial_02_Logic.html#'><b>2.1.</b> Syntax</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.2.</b> collapsibleDiv1 {</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.3.</b> collapsibleDiv2 {</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.4.</b> Semantics {#semantics}</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.5.</b> Verification Conditions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.6.</b> Examples: Propositions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.7.</b> Examples: Arithmetic</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.8.</b> Examples: Uninterpreted Function</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>3.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>3.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.5.</b> Refining Function Types: Pre-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.6.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.7.</b> Testing Values: Booleans and Propositions {#propositions}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.8.</b> Putting It All Together</a></li>
</ul>
<li><a href='Tutorial_04_Polymorphism.html'><b>4.</b>Polymorphism {#polymorphism}</a></li>
<ul class='section'>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.1.</b> Specification: Vector Bounds {#vectorbounds}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.2.</b> Verification: Vector Lookup</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.3.</b> Inference: Our First Recursive Function</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.4.</b> Higher-Order Functions: Bottling Recursion in a <code>loop</code></a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.5.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>5.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.1.</b> Sparse Vectors Revisited {#autosmart}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.2.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_06_Measure_Bool.html'><b>6.</b>Boolean Measures {#boolmeasures}</a></li>
<ul class='section'>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.1.</b> Partial Functions</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.2.</b> Lifting Functions to Measures {#usingmeasures}</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.3.</b> A Safe List API</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_07_Measure_Int.html'><b>7.</b>Numeric Measures {#numericmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.1.</b> Wholemeal Programming</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.2.</b> Specifying List Dimensions</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.3.</b> Lists: Size Preserving API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.4.</b> Lists: Size Reducing API {#listreducing}</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.5.</b> Dimension Safe Vector API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.6.</b> Dimension Safe Matrix API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>8.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>8.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>8.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>8.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>8.4.</b> Recap</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="refineddatatypes" class="level1">
<h1>Refined Datatypes</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--short-names"    @-}
{-@ LIQUID "--no-termination" @-}

module Tutorial_05_Datatypes
       (
         -- * Sparse: Data
         Sparse (..)

         -- * Sparse: Functions
       , dotProd, dotProd', plus, fromList

         -- * Sparse: Examples
       , okSP, badSP, test1, test2

          -- * OrdList: Data
       , IncList  (..)

          -- * OrdList: Examples
       , okList, badList

          -- * OrdList: Functions
       ,  insertSort, insertSort', mergeSort, quickSort

          -- * BST: Data
       , BST (..)

          -- * BST: Functions
       , mem, add, delMin, del, bstSort, toBST, toIncList

          -- * BST: Examples
       , okBST, badBST

       )
      where

import Prelude      hiding (abs, length, min)
import Data.List    (foldl')
import Data.Vector  hiding (singleton, foldl', foldr, fromList, (++))
import Data.Maybe   (fromJust)

dotProd, dotProd' :: Vector Int -> Sparse Int -> Int
test1 :: Sparse String
test2 :: Sparse Int

{-@ die :: {v:_ | false} -> a @-}
die msg = error msg

-- {-@ fail badSP @-}
-- {-@ fail test1 @-}
-- {-@ fail test2 @-}
-- {-@ fail badList @-}
-- {-@ ignore append @-}
-- {-@ fail badBST @-}
-- {-@ ignore delMin @-}


</div>
</div>

</div>

<p>So far, we have seen how to refine the types of <em>functions</em>,
to specify, for example, pre-conditions on the inputs, or
post-conditions on the outputs. Very often, we wish to define
<em>datatypes</em> that satisfy certain invariants. In these cases, it
is handy to be able to directly refine the <code>data</code> definition,
making it impossible to create illegal inhabitants.</p>
<section id="autosmart" class="level2">
<h2>Sparse Vectors Revisited</h2>
<p>As our first example of a refined datatype, let’s revisit the sparse
vector representation that we <a href="#sparsetype">saw earlier</a>. The
<code>SparseN</code> type alias we used got the job done, but is not
pleasant to work with because we have no way of determining the
<em>dimension</em> of the sparse vector. Instead, let’s create a new
datatype to represent such vectors:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">data Sparse a = SP { spDim   :: Int
                   , spElems :: [(Int, a)] }</div>
</div>

<p> Thus, a sparse vector is a pair of a dimension and a list of
index-value tuples. Implicitly, all indices <em>other</em> than those in
the list have the value <code>0</code> or the equivalent value type
<code>a</code>.</p>
<p><code>Sparse</code> vectors satisfy two crucial properties. First,
the dimension stored in <code>spDim</code> is non-negative. Second,
every index in <code>spElems</code> must be valid, i.e. between
<code>0</code> and the dimension. Unfortunately, Haskell’s type system
does not make it easy to ensure that <em>illegal vectors are not
representable</em>.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p><br />
<strong>Data Invariants</strong> LiquidHaskell lets us enforce these
invariants with a refined data definition:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ data Sparse a = SP { spDim   :: Nat
                       , spElems :: [(Btwn 0 spDim, a)]} @-}</div>
</div>

<p>Where, as before, we use the aliases:</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ type Nat        = {v:Int | 0 <= v}            @-}
{-@ type Btwn Lo Hi = {v:Int | Lo <= v && v < Hi} @-}</div>
</div>

<p><br />
<strong>Refined Data Constructors</strong> The refined data definition
is internally converted into refined types for the data constructor
<code>SP</code>:</p>
<pre class="spec"><code>-- Generated Internal representation
data Sparse a where
  SP :: spDim:Nat
     -&gt; spElems:[(Btwn 0 spDim, a)]
     -&gt; Sparse a</code></pre>
<p>In other words, by using refined input types for <code>SP</code> we
have automatically converted it into a <em>smart</em> constructor that
ensures that <em>every</em> instance of a <code>Sparse</code> is legal.
Consequently, LiquidHaskell verifies:</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">okSP :: Sparse String
okSP = SP 5 [ (0, "cat")
            , (3, "dog") ]</div>
</div>

<p>but rejects, due to the invalid index:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">badSP :: Sparse String
badSP = SP 5 [ (0, "cat")
             , (6, "dog") ]</div>
</div>

<p><br />
<strong>Field Measures</strong> It is convenient to write an alias for
sparse vectors of a given size <code>N</code>. We can use the field name
<code>spDim</code> as a <em>measure</em>, like <code>vlen</code>. That
is, we can use <code>spDim</code> inside refinements<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ type SparseN a N = {v:Sparse a | spDim v == N} @-}</div>
</div>

<p>Let’s write a function to compute a sparse product</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ dotProd :: x:Vector Int -> SparseN Int (vlen x) -> Int @-}
dotProd x (SP _ y) = go 0 y
  where
    go sum ((i, v) : y') = go (sum + (x ! i) * v) y'
    go sum []            = sum</div>
</div>

<p> LiquidHaskell verifies the above by using the specification to
conclude that for each tuple <code>(i, v)</code> in the list
<code>y</code>, the value of <code>i</code> is within the bounds of the
vector <code>x</code>, thereby proving <code>x ! i</code> safe.</p>
<p><br />
<strong>Folded Product</strong> We can port the <code>fold</code>-based
product to our new representation:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ dotProd' :: x:Vector Int -> SparseN Int (vlen x) -> Int @-}
dotProd' x (SP _ y) = foldl' body 0 y
  where
    body sum (i, v) = sum + (x ! i)  * v</div>
</div>

<p>As before, LiquidHaskell checks the above by <a
href="#sparsetype">automatically instantiating refinements</a> for the
type parameters of <code>foldl'</code>, saving us a fair bit of typing
and enabling the use of the elegant polymorphic, higher-order
combinators we know and love.</p>
<div id="Sanitization" class="hwex">
<p><br />
<strong>Exercise: (Sanitization): </strong> Invariants are all well and
good for data computed <em>inside</em> our programs. The only way to
ensure the legality of data coming from <em>outside</em>, i.e. from the
“real world”, is to write a sanitizer that will check the appropriate
invariants before constructing a <code>Sparse</code> vector. Write the
specification and implementation of a sanitizer <code>fromList</code>,
so that the following typechecks:</p>
<br />
<br />

</div>
<p><strong>Hint: </strong>You need to check that <em>all</em> the
indices in <code>elts</code> are less than <code>dim</code>; the easiest
way is to compute a new <code>Maybe [(Int, a)]</code> which is
<code>Just</code> the original pairs if they are valid, and
<code>Nothing</code> otherwise.</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">fromList          :: Int   -> [(Int, a)] -> Maybe (Sparse a)
fromList dim elts = undefined

{-@ test1 :: SparseN String 3 @-}
test1     = fromJust $ fromList 3 [(0, "cat"), (2, "mouse")]</div>
</div>

<div id="Addition" class="hwex">
<p><br />
<strong>Exercise: (Addition): </strong>Write the specification and
implementation of a function <code>plus</code> that performs the
addition of two <code>Sparse</code> vectors of the <em>same</em>
dimension, yielding an output of that dimension. When you are done, the
following code should typecheck:</p>
<br />
<br />

</div>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">plus     :: (Num a) => Sparse a -> Sparse a -> Sparse a
plus x y = undefined

{-@ test2 :: SparseN Int 3 @-}
test2    = plus vec1 vec2
  where
    vec1 = SP 3 [(0, 12), (2, 9)]
    vec2 = SP 3 [(0, 8),  (1, 100)]</div>
</div>

</section>
<section id="recap" class="level2">
<h2>Recap</h2>
<p>In this chapter we saw how LiquidHaskell lets you refine data type
definitions to capture sophisticated invariants. These definitions are
internally represented by refining the types of the data constructors,
automatically making them “smart” in that they preclude the creation of
illegal values that violate the invariants. We will see much more of
this handy technique in future chapters.</p>
<p>One recurring theme in this chapter was that we had to create new
versions of standard datatypes, just in order to specify certain
invariants. For example, we had to write a special list type, with its
own <em>copies</em> of nil and cons. Similarly, to implement
<code>delMin</code> we had to create our own pair type.</p>
<p><br />
<strong>This duplication</strong> of types is quite tedious. There
should be a way to just slap the desired invariants on to
<em>existing</em> types, thereby facilitating their reuse. In a few
chapters, we will see how to achieve this reuse by <a
href="http://goto.ucsd.edu/~rjhala/liquid/abstract_refinement_types.pdf">abstracting
refinements</a> from the definitions of datatypes or functions in the
same way we abstract the element type <code>a</code> from containers
like <code>[a]</code> or <code>BST a</code>.</p>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The standard approach is to use abstract types and <a
href="https://www.haskell.org/haskellwiki/Smart_constructors">smart
constructors</a> but even then there is only the informal guarantee that
the smart constructor establishes the right invariants.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note that <em>inside</em> a refined <code>data</code>
definition, a field name like <code>spDim</code> refers to the value of
the field, but <em>outside</em> it refers to the field selector measure
or function.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>

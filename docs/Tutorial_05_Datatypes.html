<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">
    <link rel="stylesheet" type="text/css" href="./css/short-tutorial.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>
<script type="text/javascript" src="./js/short-tutorial.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> Refinement Types</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>2.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>2.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>2.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>2.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>2.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>2.5.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>2.6.</b> Dependent Refinements</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>3.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>3.1.</b> Sparse Vectors {#autosmart}</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>4.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>4.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>4.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>4.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>4.4.</b> Queue Operations</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>4.5.</b> Recap of everyting!</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="refineddatatypes" class="level1">
<h1>Refined Datatypes</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--short-names"    @-}
{-@ LIQUID "--no-termination" @-}

module Tutorial_05_Datatypes
       (
         -- * Sparse: Data
         Sparse (..)

         -- * Sparse: Functions
       , dotProd, dotProd', plus, fromList

         -- * Sparse: Examples
       , okSP, badSP, test1, test2

          -- * OrdList: Data
       , IncList  (..)

          -- * OrdList: Examples
       , okList, badList

          -- * OrdList: Functions
       ,  insertSort, insertSort', mergeSort, quickSort

          -- * BST: Data
       , BST (..)

          -- * BST: Functions
       , mem, add, delMin, del, bstSort, toBST, toIncList

          -- * BST: Examples
       , okBST, badBST

       )
      where

import Prelude      hiding (abs, length, min)
import Data.List    (foldl')
import Data.Vector  hiding (singleton, foldl', foldr, fromList, (++))
import Data.Maybe   (fromJust)

dotProd, dotProd' :: Vector Int -> Sparse Int -> Int
test1 :: Sparse String
test2 :: Sparse Int

{-@ die :: {v:_ | false} -> a @-}
die msg = error msg

-- {-@ fail badSP @-}
-- {-@ fail test1 @-}
-- {-@ fail test2 @-}
-- {-@ fail badList @-}
-- {-@ ignore append @-}
-- {-@ fail badBST @-}
-- {-@ ignore delMin @-}


</div>
</div>

</div>

<p>So far, we have seen how to refine the types of <em>functions</em>,
to specify, for example, pre-conditions on the inputs, or
post-conditions on the outputs. Very often, we wish to define
<em>datatypes</em> that satisfy certain invariants. In these cases, it
is handy to be able to directly refine the <code>data</code> definition,
making it impossible to create illegal inhabitants.</p>
<section id="autosmart" class="level2">
<h2>Sparse Vectors</h2>
<p>As our first example of a refined datatype, let’s see Sparse Vectors.
While the standard Vector is great for dense arrays, often we have to
manipulate sparse vectors where most elements are just 0. We might
represent such vectors as a list of index-value tuples
<code>[(Int, a)]</code>.</p>
<p>Let’s create a new datatype to represent such vectors:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">data Sparse a = SP { spDim   :: Int
                   , spElems :: [(Int, a)] }</div>
</div>

<p> Thus, a sparse vector is a pair of a dimension and a list of
index-value tuples. Implicitly, all indices <em>other</em> than those in
the list have the value <code>0</code> or the equivalent value type
<code>a</code>.</p>
<p><code>Sparse</code> vectors satisfy two crucial properties. 1) the
dimension stored in <code>spDim</code> is non-negative; 2) every index
in <code>spElems</code> must be valid, i.e. between <code>0</code> and
the dimension.</p>
<p>Unfortunately, Haskell’s type system does not make it easy to ensure
that <em>illegal vectors are not representable</em>.</p>
<p><br />
<strong>Data Invariants</strong> LiquidHaskell lets us enforce these
invariants with a refined data definition:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ data Sparse a = SP { spDim   :: Nat
                       , spElems :: [(Btwn 0 spDim, a)]} @-}</div>
</div>

<p>Where, as before, we use the aliases:</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ type Nat        = {v:Int | 0 <= v}            @-}
{-@ type Btwn Lo Hi = {v:Int | Lo <= v && v < Hi} @-} </div>
</div>

<p><br />
<strong>Refined Data Constructors</strong> The refined data definition
is internally converted into refined types for the data constructor
<code>SP</code>. So, by using refined input types for <code>SP</code> we
have automatically converted it into a <em>smart</em> constructor that
ensures that <em>every</em> instance of a <code>Sparse</code> is legal.
Consequently, LiquidHaskell verifies:</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">okSP :: Sparse String
okSP = SP 5 [ (0, "cat")
            , (3, "dog") ]</div>
</div>

<p>but rejects, due to the invalid index:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">badSP :: Sparse String
badSP = SP 5 [ (0, "cat")
             , (6, "dog") ]</div>
</div>

<div class="interact">
Write another example of a Sparse data type that is invalid.
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">badSP' :: Sparse String</div>
</div>

<div>
<button class="btn-answer" onclick="toggleCollapsible(1)">
Answer</button>
<div id="collapsibleDiv1">
e.g., <code>badSP' = SP -1 [(0, "cat")]</code>
</div>
</div>
</div>
<p><br />
<strong>Field Measures</strong> It is convenient to write an alias for
sparse vectors of a given size <code>N</code>. So that we can easily say
in a refinement that we have a sparse vector of a certain size.</p>
<p>For this we can use <em>measures</em>.</p>
<p><br />
<strong>Measures</strong> are used to define <em>properties</em> of
Haskell data values that are useful for specification and
verification.</p>
<p><br />
<strong>A measure</strong> is a <em>total</em> Haskell function, 1. With
a <em>single</em> equation per data constructor, and 2. Guaranteed to
<em>terminate</em>, typically via structural recursion.</p>
<p> We can tell LiquidHaskell to <em>lift</em> a function meeting the
above requirements into the refinement logic by declaring:</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ measure nameOfMeasure @-}</div>
</div>

<p>For example, for a list we can define a way to <em>measure</em> its
size with the following function.</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ measure size @-}
{-@ size :: [a] -> Nat @-}
size []     = 0
size (_:rs) = 1 + size rs</div>
</div>

<p>Then, we can use this measure to define aliases.</p>
<div class="interact">
<p>But first, let’s create another measure named <code>notEmpty</code>
that takes a list as input and returns a <code>Bool</code> with the
information if it is empty or not.</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ measure notEmpty @-}</div>
</div>

<div>
<button class="btn-answer" onclick="toggleCollapsible(2)">
Answer</button>
<div id="collapsibleDiv2">
<code>{-@ measure notEmpty @-}</code><br/>
<code>notEmpty       :: [a] -&gt; Bool</code>
<code>notEmpty []    = False</code> <code>notEmpty (_:_) = True</code>
</div>
</div>
</div>
<p>We can now define a couple of useful aliases for describing lists of
a given dimension.</p>
<p>And now, we can define that a list has exactly <code>N</code>
elements.</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ type ListN a N = {v:[a] | size v == N} @-}</div>
</div>

<p>Note that when defining refinement type aliases, we use uppercase
variables like <code>N</code> to distinguish <em>value</em> parameters
from the lowercase <em>type</em> parameters like <code>a</code>.</p>
<div class="interact">
<p>Now, try to create an alias for an empty list, using the measure
<code>notEmpty</code> created before.</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">{-@ type NEList a = {TRUE} @-}

{-@ ne1 :: NEList Int@-}
ne1 = [] ::  [Int]
{-@ ne1 :: NEList Int@-}
ne2 = [1,2,3,4] :: [Int]</div>
</div>

<button class="btn-answer" onclick="toggleCollapsible(4)">
Answer
</button>
<pre><code>&lt;div id=&quot;collapsibleDiv4&quot;&gt;</code></pre>
<code>{-@ type NEList a = {v:[a] | notEmpty v} @-}</code>
</div>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">/div></div>
</div>

<p>Similarly, the sparse vector also has a <em>measure</em> for its
dimension, but in this case it is already defined by <code>spDim</code>,
so we can use it to create the new alias of sparse vectors of size
N.</p>
<div class="interact">
<p>Now, following what we did with the lists, write the alias for sparse
vector, using <code>spDim</code> instead of <code>size</code>.</p>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">{-@ type SparseN a N = {TRUE} @-}</div>
</div>

<button class="btn-answer" onclick="toggleCollapsible(5)">
Answer
</button>
<pre><code>&lt;div id=&quot;collapsibleDiv5&quot;&gt;</code></pre>
<code>{-@ type SparseN a N = {v:Sparse a | spDim v == N} @-}</code>
</div>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">/div></div>
</div>

<p><code>Vector</code>s are similar to Sparse Vectors, and therefore,
have a <em>measure</em> of size named <code>vlen</code>.</p>
<p>So, now, we can see that LiquidHaskell is able to compute a sparse
product, making the product of all the same indexes and returning its
sum. Run the code ahead.</p>
<div id="program-pane-15" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-15" class="programbox">{-@ dotProd :: x:Vector Int -> SparseN Int (vlen x) -> Int @-}
dotProd x (SP _ y) = go 0 y
  where
    go sum ((i, v) : y') = go (sum + (x ! i) * v) y'
    go sum []            = sum</div>
</div>

<p> LiquidHaskell verifies the above by using the specification to
conclude that for each tuple <code>(i, v)</code> in the list
<code>y</code>, the value of <code>i</code> is within the bounds of the
vector <code>x</code>, thereby proving <code>x ! i</code> safe.</p>
<p><br />
<strong>Folded Product</strong> We can port the <code>fold</code>-based
product to our new representation:</p>
<div id="program-pane-16" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-16" class="programbox">{-@ dotProd' :: x:Vector Int -> SparseN Int (vlen x) -> Int @-}
dotProd' x (SP _ y) = foldl' body 0 y
  where
    body sum (i, v) = sum + (x ! i)  * v</div>
</div>

<p>As before, LiquidHaskell checks the above by <a
href="#sparsetype">automatically instantiating refinements</a> for the
type parameters of <code>foldl'</code>, saving us a fair bit of typing
and enabling the use of the elegant polymorphic, higher-order
combinators we know and love.</p>
<p><a href="Tutorial_09_Case_Study_Lazy_Queues.html" >
<button class="btn-next">Next</button> </a></p>
</section>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
